{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#pytauri","title":"PyTauri","text":"<p>Tauri bindings for Python through Pyo3</p> <p></p> <p>Documentation: https://wsh032.github.io/pytauri/</p> <p>Source Code: https://github.com/WSH032/pytauri/</p>"},{"location":"#features","title":"Features","text":"<p>TL;DR</p> <p>You are hurry and just wanna see/run the demo? See examples/tauri-app.</p> <ul> <li>Need Rust compiler, but almost don't need to write Rust code!</li> <li>Can be integrated with <code>tauri-cli</code> to build and package standalone executables!</li> <li>No IPC (inter-process communication) overhead, secure and fast, thanks to Pyo3!</li> <li> <p>Support Tauri official plugins(e.g., notification), and you can write your own plugins!</p> <p></p> </li> <li> <p>Natively support async python (<code>asyncio</code>, <code>trio</code> or <code>anyio</code>)</p> </li> <li>100% Type Completeness</li> <li> <p>Ergonomic API (and as close as possible to the Tauri Rust API)</p> <ul> <li> <p>Python</p> <pre><code>import sys\n\nfrom pydantic import BaseModel\nfrom pytauri import (\n    AppHandle,\n    Commands,\n)\nfrom pytauri_plugin_notification import NotificationBuilderArgs, NotificationExt\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person, app_handle: AppHandle) -&gt; Greeting:\n    notification_builder = NotificationExt.builder(app_handle)\n    notification_builder.show(\n        NotificationBuilderArgs(title=\"Greeting\", body=f\"Hello, {body.name}!\")\n    )\n\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n</code></pre> </li> <li> <p>Frontend</p> <pre><code>import { pyInvoke } from \"tauri-plugin-pytauri-api\";\n// or: `const { pyInvoke } = window.__TAURI__.pytauri;`\n\nexport interface Person {\n    name: string;\n}\n\nexport interface Greeting {\n    message: string;\n}\n\nexport async function greet(body: Person): Promise&lt;Greeting&gt; {\n    return await pyInvoke(\"greet\", body);\n}\n</code></pre> </li> </ul> </li> </ul>"},{"location":"#release","title":"Release","text":"<p>We follow Semantic Versioning 2.0.0.</p> <p>Rust and its Python bindings, PyTauri core and its plugins will keep the same <code>MAJOR.MINOR</code> version number.</p> name pypi crates.io npmjs \ud83d\udc49 core - - - pytauri pytauri-core tauri-plugin-pytauri \ud83d\udc49 plugins - - - pytauri-plugin-notification \ud83d\udc49 utils - - - pyo3-utils codelldb"},{"location":"#philosophy","title":"Philosophy","text":""},{"location":"#for-pythoneer","title":"For Pythoneer","text":"<p>I hope <code>PyTauri</code> can become an alternative to pywebview and Pystray, leveraging Tauri's comprehensive features to offer Python developers a GUI framework and a batteries-included development experience similar to electron and PySide.</p> <p>PyTauri is inspired by FastAPI and Pydantic, aiming to offer a similar development experience.</p>"},{"location":"#for-rustacean","title":"For Rustacean","text":"<p>Through Pyo3, I hope Rust developers can better utilize the Python ecosystem (e.g., building AI GUI applications with PyTorch).</p> <p>Although Rust's lifetime and ownership system makes Rust code safer, Python's garbage collection (GC) will make life easier. \ud83d\ude06</p>"},{"location":"#the-future","title":"The Future","text":"<p>In the future, I hope PyTauri can integrate with nicegui and gradio, bringing you a Python full-stack (i.g., without <code>Node.js</code>) development experience.</p>"},{"location":"#credits","title":"Credits","text":"<p>PyTauri is a project that aims to provide Python bindings for Tauri, a cross-platform webview GUI library. <code>Tauri</code> is a trademark of the Tauri Program within the Commons Conservancy and PyTauri is not officially endorsed or supported by them. PyTauri is an independent and community-driven effort that respects the original goals and values of Tauri. PyTauri does not claim any ownership or affiliation with the Tauri Program.</p>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the Apache License 2.0.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>pyo3_utils</li> <li>pytauri_plugin_notification<ul> <li>ffi</li> </ul> </li> <li>pytauri<ul> <li>ffi<ul> <li>ipc</li> <li>lib</li> </ul> </li> <li>ipc</li> </ul> </li> <li>codelldb</li> </ul>"},{"location":"reference/codelldb/","title":"codelldb","text":""},{"location":"reference/codelldb/#codelldb","title":"codelldb","text":"<p>Launch CodeLLDB in debugpy to debug rust code.</p>"},{"location":"reference/codelldb/#codelldb--usage","title":"Usage","text":"<p>Tip</p> <p>This package only depends on the Python standard library, so you can integrate it freely.</p>"},{"location":"reference/codelldb/#codelldb--configuring-codelldb-rpc-server","title":"Configuring CodeLLDB rpc server","text":"<p>Please refer to the CodeLLDB documentation to set up the rpc server, and add the following content to <code>.vscode/settings.json</code>:</p> <pre><code>{\n  \"lldb.rpcServer\": {\n    \"host\": \"127.0.0.1\",\n    \"port\": 9552,\n    \"token\": \"secret\",\n  }\n}\n</code></pre>"},{"location":"reference/codelldb/#codelldb--configuring-python-debugger","title":"Configuring Python Debugger","text":"<p>Please refer to the Python Debugger documentation, and add the following content to <code>.vscode/launch.json</code>:</p> <pre><code>{\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n        {\n            \"name\": \"python.debug\",\n            \"type\": \"debugpy\",\n            \"purpose\": [\n                \"debug-in-terminal\"\n            ],\n            \"console\": \"integratedTerminal\",\n            \"request\": \"launch\",\n            // see: &lt;https://code.visualstudio.com/docs/python/debugging#_set-configuration-options&gt;\n            \"module\": \"pytauri_demo\", // your module name\n            \"args\": [], // whatever you want\n            // following env vars will be used by `codelldb` package\n            \"env\": {\n                \"VSCODE_RUST_DEBUG\": \"${input:rustDebug}\",\n                // keep the following env vars in sync with `.vscode/settings.json`\n                \"VSCODE_LLDB_RPC_SERVER_HOST\": \"127.0.0.1\",\n                \"VSCODE_LLDB_RPC_SERVER_PORT\": \"9552\",\n                \"VSCODE_LLDB_RPC_SERVER_TOKEN\": \"secret\",\n            },\n        }\n    ],\n    // see: &lt;https://code.visualstudio.com/docs/editor/variables-reference#_input-variables&gt;\n    \"inputs\": [\n        {\n            \"type\": \"pickString\",\n            \"id\": \"rustDebug\",\n            \"description\": \"Whether to enable Rust debugging\",\n            \"options\": [\n                {\n                    \"label\": \"Enabled\",\n                    \"value\": \"1\"\n                },\n                {\n                    \"label\": \"Disabled\",\n                    \"value\": \"0\"\n                }\n            ],\n            \"default\": \"0\"\n        },\n    ]\n}\n</code></pre>"},{"location":"reference/codelldb/#codelldb--multi-target-debugging","title":"Multi-target debugging","text":"<p>When starting Python Debugger via <code>F5</code>, you will see a selection box, choose <code>Enabled</code> to enable Rust debugging.</p> <p>Functions:</p> Name Description <code>debug</code> <p>Launch CodeLLDB to debug rust code.</p>"},{"location":"reference/codelldb/#codelldb.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['debug']\n</code></pre>"},{"location":"reference/codelldb/#codelldb.VSCODE_RUST_DEBUG_VARNAME","title":"VSCODE_RUST_DEBUG_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_RUST_DEBUG_VARNAME = 'VSCODE_RUST_DEBUG'\n</code></pre> <p>Whether to enable Rust debugging, set to <code>1</code> to enable, <code>0</code> to disable.</p>"},{"location":"reference/codelldb/#codelldb.VSCODE_LLDB_RPC_SERVER_HOST_VARNAME","title":"VSCODE_LLDB_RPC_SERVER_HOST_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_LLDB_RPC_SERVER_HOST_VARNAME = 'VSCODE_LLDB_RPC_SERVER_HOST'\n</code></pre> <p>The host of the CodeLLDB rpc server.</p>"},{"location":"reference/codelldb/#codelldb.VSCODE_LLDB_RPC_SERVER_PORT_VARNAME","title":"VSCODE_LLDB_RPC_SERVER_PORT_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_LLDB_RPC_SERVER_PORT_VARNAME = 'VSCODE_LLDB_RPC_SERVER_PORT'\n</code></pre> <p>The port of the CodeLLDB rpc server.</p>"},{"location":"reference/codelldb/#codelldb.VSCODE_LLDB_RPC_SERVER_TOKEN_VARNAME","title":"VSCODE_LLDB_RPC_SERVER_TOKEN_VARNAME  <code>module-attribute</code>","text":"<pre><code>VSCODE_LLDB_RPC_SERVER_TOKEN_VARNAME = 'VSCODE_LLDB_RPC_SERVER_TOKEN'\n</code></pre> <p>The secret token of the CodeLLDB rpc server.</p>"},{"location":"reference/codelldb/#codelldb.DEFAULT_HOST","title":"DEFAULT_HOST  <code>module-attribute</code>","text":"<pre><code>DEFAULT_HOST = '127.0.0.1'\n</code></pre>"},{"location":"reference/codelldb/#codelldb.DebugError","title":"DebugError","text":"<p>               Bases: <code>Exception</code></p>"},{"location":"reference/codelldb/#codelldb.debug","title":"debug","text":"<pre><code>debug() -&gt; None\n</code></pre> <p>Launch CodeLLDB to debug rust code.</p> <p>If the value indicated by VSCODE_RUST_DEBUG_VARNAME is not <code>1</code>, this is a no-op.</p> <p>Raises:</p> Type Description <code>DebugError</code> <p>If the provided environment variables cannot be correctly parsed.</p> Note <p>If failed to connect to the lldb rpc server, a warning message will be logged instead of raising an exception.</p> Source code in <code>python/codelldb/src/codelldb/__init__.py</code> <pre><code>def debug() -&gt; None:\n    \"\"\"Launch CodeLLDB to debug rust code.\n\n    If the value indicated by [VSCODE_RUST_DEBUG_VARNAME][codelldb.VSCODE_RUST_DEBUG_VARNAME] is not `1`, this is a no-op.\n\n    Raises:\n        DebugError: If the provided environment variables cannot be correctly parsed.\n\n    Note:\n        If failed to connect to the lldb rpc server, a warning message will be logged instead of raising an exception.\n    \"\"\"\n    vscode_rust_debug = getenv(VSCODE_RUST_DEBUG_VARNAME)\n    if vscode_rust_debug != \"1\":\n        return\n\n    _logger.info(f\"'{VSCODE_RUST_DEBUG_VARNAME}' is set, enabling rust debug mode\")\n\n    lldb_rpc_server_cfg = _get_lldb_rpc_server_cfg()\n\n    host = lldb_rpc_server_cfg[\"host\"]\n    port = lldb_rpc_server_cfg[\"port\"]\n    token = lldb_rpc_server_cfg[\"token\"]\n\n    token_data = f\"token: {token}\" if token else \"\"\n    # See: &lt;https://github.com/vadimcn/codelldb/blob/v1.10.0/MANUAL.md#rpc-server&gt;\n    # Line-oriented YAML Syntax: &lt;https://github.com/vadimcn/codelldb/blob/v1.10.0/MANUAL.md#debugging-externally-launched-code&gt;\n    # Arg: &lt;https://github.com/vadimcn/codelldb/blob/v1.10.0/MANUAL.md#attaching-to-a-running-process&gt;\n    rpc_data = dedent(f\"\"\"\\\n        name: \"rust.debug\"\n        type: \"lldb\"\n        request: \"attach\"\n        pid: {getpid()}\n        sourceLanguages:\n            - rust\n            - c\n            - cpp\n        {token_data}\n    \"\"\")\n\n    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:\n        s.connect((host, port))\n\n        s.sendall(rpc_data.encode(\"utf-8\"))\n\n        s.shutdown(socket.SHUT_WR)\n\n        response = s.recv(1024)\n\n        if not response:\n            _logger.warning(\n                \"Failed to get response from lldb rpc server, \"\n                \"maybe the rpc `token` is not correct.\"\n            )\n            return\n\n        try:\n            response = json.loads(response)\n            assert isinstance(response, dict)\n        except Exception as e:\n            _logger.warning(\n                f\"Failed to parse response from lldb rpc server: {response}\", exc_info=e\n            )\n            return\n\n        if response.get(\"success\") is not True:  # pyright: ignore[reportUnknownMemberType]\n            _logger.warning(\n                f\"Seems like lldb rpc server failed to attach to the process: {response}\"\n            )\n            return\n</code></pre>"},{"location":"reference/pyo3_utils/","title":"pyo3_utils","text":""},{"location":"reference/pyo3_utils/#pyo3_utils","title":"pyo3_utils","text":"<p>Python integration for the <code>pyo3-utils</code> crate.</p> <p>Classes:</p> Name Description <code>PyMatchRefMixin</code> <p>Rust <code>match &amp;self</code> for Python.</p> <code>PyMatchMutMixin</code> <p>Rust <code>match &amp;mut self</code> for Python.</p> <code>PyMatchIntoMixin</code> <p>Rust <code>match self</code> for Python.</p>"},{"location":"reference/pyo3_utils/#pyo3_utils.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['PyMatchIntoMixin', 'PyMatchMutMixin', 'PyMatchRefMixin']\n</code></pre>"},{"location":"reference/pyo3_utils/#pyo3_utils.PyMatchRefMixin","title":"PyMatchRefMixin","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Rust <code>match &amp;self</code> for Python.</p> <p>This class is only used to provide type annotations, the actual implementation of the methods is handled by the pyo3 extension module.</p> Note <p>This class can only be used when <code>TYPE_CHECKING</code>.</p> <p>Methods:</p> Name Description <code>match_ref</code> <p>Equivalent to <code>match &amp;self</code> in Rust.</p>"},{"location":"reference/pyo3_utils/#pyo3_utils.PyMatchRefMixin.match_ref","title":"match_ref","text":"<pre><code>match_ref() -&gt; _T\n</code></pre> <p>Equivalent to <code>match &amp;self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_ref(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match &amp;self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pyo3_utils/#pyo3_utils.PyMatchMutMixin","title":"PyMatchMutMixin","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Rust <code>match &amp;mut self</code> for Python.</p> <p>This class is only used to provide type annotations, the actual implementation of the methods is handled by the pyo3 extension module.</p> Note <p>This class can only be used when <code>TYPE_CHECKING</code>.</p> <p>Methods:</p> Name Description <code>match_mut</code> <p>Equivalent to <code>match &amp;mut self</code> in Rust.</p>"},{"location":"reference/pyo3_utils/#pyo3_utils.PyMatchMutMixin.match_mut","title":"match_mut","text":"<pre><code>match_mut() -&gt; _T\n</code></pre> <p>Equivalent to <code>match &amp;mut self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_mut(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match &amp;mut self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pyo3_utils/#pyo3_utils.PyMatchIntoMixin","title":"PyMatchIntoMixin","text":"<p>               Bases: <code>Generic[_T]</code></p> <p>Rust <code>match self</code> for Python.</p> <p>This class is only used to provide type annotations, the actual implementation of the methods is handled by the pyo3 extension module.</p> Note <p>This class can only be used when <code>TYPE_CHECKING</code>.</p> <p>Methods:</p> Name Description <code>match_into</code> <p>Equivalent to <code>match self</code> in Rust.</p>"},{"location":"reference/pyo3_utils/#pyo3_utils.PyMatchIntoMixin.match_into","title":"match_into","text":"<pre><code>match_into() -&gt; _T\n</code></pre> <p>Equivalent to <code>match self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_into(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/","title":"pytauri","text":""},{"location":"reference/pytauri/#pytauri","title":"pytauri","text":"<p>tauri::self</p> <p>Modules:</p> Name Description <code>ffi</code> <p>Original FFI interface module.</p> <code>ipc</code> <p>tauri::ipc</p> <p>Classes:</p> Name Description <code>App</code> <p>Tauri::app</p> <code>AppHandle</code> <p>tauri::AppHandle</p> <code>Builder</code> <p>Tauri::Builder</p> <code>BuilderArgs</code> <code>Context</code> <p>tauri::Context</p> <code>RunEvent</code> <p>tauri::RunEvent</p> <code>RunEventEnum</code> <p>tauri::RunEvent</p> <code>Commands</code> <p>This class provides features similar to tauri::generate_handler.</p> <p>Functions:</p> Name Description <code>builder_factory</code> <p>A factory function for creating a <code>Builder</code> instance.</p> <code>context_factory</code> <p>A factory function for creating a <code>Context</code> instance.</p> <p>Attributes:</p> Name Type Description <code>EXT_MOD</code> <code>ModuleType</code> <p>The extension module of <code>pytauri</code> app.</p> <code>RunEventEnumType</code> <code>TypeAlias</code> <p>See RunEventEnum for details.</p>"},{"location":"reference/pytauri/#pytauri.EXT_MOD","title":"EXT_MOD  <code>module-attribute</code>","text":"<pre><code>EXT_MOD: ModuleType\n</code></pre> <p>The extension module of <code>pytauri</code> app.</p> <p>It will be loaded from <code>entry_points(group=\"pytauri\", name=\"ext_mod\")</code>.</p> <p>Usually you don't need to use it, unless you want to write plugins for <code>pytauri</code>.</p>"},{"location":"reference/pytauri/#pytauri.RunEventEnumType","title":"RunEventEnumType  <code>module-attribute</code>","text":"<pre><code>RunEventEnumType: TypeAlias = Union[Exit, ExitRequested, WindowEvent, WebviewEvent, Ready, Resumed, MainEventsCleared, MenuEvent]\n</code></pre> <p>See RunEventEnum for details.</p>"},{"location":"reference/pytauri/#pytauri.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['EXT_MOD', 'App', 'AppHandle', 'Builder', 'BuilderArgs', 'Commands', 'Context', 'RunEvent', 'RunEventEnum', 'RunEventEnumType', 'builder_factory', 'context_factory']\n</code></pre>"},{"location":"reference/pytauri/#pytauri.App","title":"App","text":"<p>Tauri::app</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>run</code> <p>Consume and run this app, will block until the app is exited.</p> <code>run_iteration</code> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <code>cleanup_before_exit</code> <p>Runs necessary cleanup tasks before exiting the process.</p>"},{"location":"reference/pytauri/#pytauri.App.run","title":"run","text":"<pre><code>run(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Consume and run this app, will block until the app is exited.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each event. It will be called on the same thread that the app was created on, so you should not block in this function.</p> <code>None</code> <p>Warning</p> <p>If <code>callback</code> is specified, it must not raise an exception, otherwise it is undefined behavior, and in most cases, the program will panic.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; None:\n    \"\"\"Consume and run this app, will block until the app is exited.\n\n    Args:\n        callback: a callback function that will be called on each event.\n            It will be called on the same thread that the app was created on,\n            so you should not block in this function.\n\n    !!! warning\n        If `callback` is specified, it must not raise an exception,\n        otherwise it is undefined behavior, and in most cases, the program will panic.\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/#pytauri.App.run(callback)","title":"<code>callback</code>","text":""},{"location":"reference/pytauri/#pytauri.App.run_iteration","title":"run_iteration","text":"<pre><code>run_iteration(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each iteration.</p> <code>None</code> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> <p>Tip</p> <p>Approximately 2ms per calling in debug mode.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_iteration(\n    self, callback: Optional[_AppRunCallbackType] = None, /\n) -&gt; None:\n    \"\"\"Run this app iteratively without consuming it, calling `callback` on each iteration.\n\n    Args:\n        callback: a callback function that will be called on each iteration.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n\n    !!! tip\n        Approximately 2ms per calling in debug mode.\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/#pytauri.App.run_iteration(callback)","title":"<code>callback</code>","text":""},{"location":"reference/pytauri/#pytauri.App.cleanup_before_exit","title":"cleanup_before_exit","text":"<pre><code>cleanup_before_exit() -&gt; None\n</code></pre> <p>Runs necessary cleanup tasks before exiting the process.</p> <p>You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def cleanup_before_exit(self, /) -&gt; None:\n    \"\"\"Runs necessary cleanup tasks before exiting the process.\n\n    **You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.**\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/#pytauri.AppHandle","title":"AppHandle","text":"<p>tauri::AppHandle</p>"},{"location":"reference/pytauri/#pytauri.Builder","title":"Builder","text":"<p>Tauri::Builder</p> <p>use builder_factory to instantiate this class.</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>build</code> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p>"},{"location":"reference/pytauri/#pytauri.Builder.build","title":"build","text":"<pre><code>build(args: BuilderArgs) -&gt; App\n</code></pre> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def build(self, args: BuilderArgs, /) -&gt; App:\n    \"\"\"Consume this builder and build an app with the given `BuilderArgs`.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/#pytauri.BuilderArgs","title":"BuilderArgs","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>tauri::Builder</p>"},{"location":"reference/pytauri/#pytauri.BuilderArgs.__new__","title":"__new__","text":"<pre><code>__new__(*, context: Context, invoke_handler: Optional[_InvokeHandlerProto] = None) -&gt; Self\n</code></pre> <p>tauri::Builder</p> <p>Warning</p> <p>The implementer of <code>invoke_handler</code> must never raise an exception, otherwise it is considered undefined behavior. Additionally, <code>invoke_handler</code> must not block.</p> <p>Parameters:</p> Name Type Description Default <code>Context</code> <p>use context_factory to get it.</p> required <code>Optional[_InvokeHandlerProto]</code> <p>use Commands to get it.</p> <code>None</code> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    context: \"Context\",\n    invoke_handler: Optional[_InvokeHandlerProto] = None,\n) -&gt; Self:\n    \"\"\"[tauri::Builder](https://docs.rs/tauri/latest/tauri/struct.Builder.html)\n\n    !!! warning\n        The implementer of `invoke_handler` must never raise an exception,\n        otherwise it is considered undefined behavior.\n        Additionally, `invoke_handler` must not block.\n\n    Args:\n        context: use [context_factory][pytauri.context_factory] to get it.\n        invoke_handler: use [Commands][pytauri.ipc.Commands] to get it.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/#pytauri.BuilderArgs.__new__(context)","title":"<code>context</code>","text":""},{"location":"reference/pytauri/#pytauri.BuilderArgs.__new__(invoke_handler)","title":"<code>invoke_handler</code>","text":""},{"location":"reference/pytauri/#pytauri.Context","title":"Context","text":"<p>tauri::Context</p>"},{"location":"reference/pytauri/#pytauri.RunEvent","title":"RunEvent","text":"<p>               Bases: <code>PyMatchRefMixin['RunEventEnumType']</code></p> <p>tauri::RunEvent</p> <p>Methods:</p> Name Description <code>match_ref</code> <p>Equivalent to <code>match &amp;self</code> in Rust.</p>"},{"location":"reference/pytauri/#pytauri.RunEvent.match_ref","title":"match_ref","text":"<pre><code>match_ref() -&gt; _T\n</code></pre> <p>Equivalent to <code>match &amp;self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_ref(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match &amp;self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/#pytauri.RunEventEnum","title":"RunEventEnum","text":"<p>tauri::RunEvent</p> <p>Classes:</p> Name Description <code>Exit</code> <p>tauri::RunEvent::Exit</p> <code>ExitRequested</code> <p>tauri::RunEvent::ExitRequested</p> <code>WindowEvent</code> <p>tauri::RunEvent::WindowEvent</p> <code>WebviewEvent</code> <p>tauri::RunEvent::WebviewEvent</p> <code>Ready</code> <p>tauri::RunEvent::Ready</p> <code>Resumed</code> <p>tauri::RunEvent::Resumed</p> <code>MainEventsCleared</code> <p>tauri::RunEvent::MainEventsCleared</p> <code>MenuEvent</code> <p>tauri::RunEvent::MenuEvent</p>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.Exit","title":"Exit","text":"<p>tauri::RunEvent::Exit</p>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.ExitRequested","title":"ExitRequested","text":"<p>tauri::RunEvent::ExitRequested</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>Optional[int]</code>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.ExitRequested.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Optional[int]\n</code></pre>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.WindowEvent","title":"WindowEvent","text":"<p>tauri::RunEvent::WindowEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.WindowEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::RunEvent::WebviewEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.WebviewEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.Ready","title":"Ready","text":"<p>tauri::RunEvent::Ready</p>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.Resumed","title":"Resumed","text":"<p>tauri::RunEvent::Resumed</p>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.MainEventsCleared","title":"MainEventsCleared","text":"<p>tauri::RunEvent::MainEventsCleared</p>"},{"location":"reference/pytauri/#pytauri.RunEventEnum.MenuEvent","title":"MenuEvent","text":"<p>tauri::RunEvent::MenuEvent</p>"},{"location":"reference/pytauri/#pytauri.Commands","title":"Commands","text":"<pre><code>Commands()\n</code></pre> <p>               Bases: <code>UserDict[str, _PyInvokHandleData]</code></p> <p>This class provides features similar to tauri::generate_handler.</p> <p>Typically, you would use Commands.command to register a command handler function. Then, use Commands.generate_handler to get an <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Methods:</p> Name Description <code>generate_handler</code> <p>This method is similar to tauri::generate_handler.</p> <code>wrap_pyfunc</code> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <code>parse_parameters</code> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <code>set_command</code> <p>Set a command handler.</p> <code>command</code> <p>A decorator to register a command handler.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self) -&gt; None:  # noqa: D107\n    super().__init__()\n\n    data = self.data\n\n    async def _async_invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - the implementer of this function must not raise exceptions\n        # - and must ensure to fulfill `invoke/resolver`\n        resolver = None\n        try:\n            command = invoke.command\n            handler_data = data.get(command)\n            if handler_data is None:\n                invoke.reject(f\"no python handler `{command}` found\")\n                return\n\n            parameters = handler_data.parameters\n            handler = handler_data.handler\n\n            resolver = invoke.bind_to(parameters)\n            if resolver is None:\n                # `invoke` has already been rejected\n                return\n\n            try:\n                resp = await handler(**resolver.arguments)\n                # TODO, PERF: idk if this will block?\n            except InvokeException as e:\n                resolver.reject(e.value)\n            except Exception as e:\n                # # TODO: Should we return the traceback to the frontend?\n                # # It might leak information.\n                # from traceback import format_exc\n                # resolver.reject(format_exc())\n                _logger.exception(\n                    f\"invoke_handler {handler}: `{handler.__name__}` raised an exception\",\n                    exc_info=e,\n                )\n                resolver.reject(repr(e))\n            else:\n                resolver.resolve(resp)\n\n        except Exception as e:\n            msg = f\"{_async_invoke_handler} implementation raised an exception, please report this as a pytauri bug\"\n\n            _logger.critical(msg, exc_info=e)\n            if resolver is not None:\n                resolver.reject(msg)\n            else:\n                invoke.reject(msg)\n            raise\n\n    self._async_invoke_handler = _async_invoke_handler\n</code></pre>"},{"location":"reference/pytauri/#pytauri.Commands.generate_handler","title":"generate_handler","text":"<pre><code>generate_handler(portal: BlockingPortal) -&gt; _InvokeHandlerProto\n</code></pre> <p>This method is similar to tauri::generate_handler.</p> <p>You can use this method to get <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Examples:</p> <pre><code>from anyio.from_thread import start_blocking_portal\n\ncommands = Commands()\n\nwith start_blocking_portal(backend) as portal:\n    invoke_handler = commands.generate_handler(portal)\n    ...\n</code></pre> <p>Warning</p> <p>The <code>portal</code> must remain valid while the returned <code>invoke_handler</code> is being used.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def generate_handler(self, portal: BlockingPortal, /) -&gt; _InvokeHandlerProto:\n    \"\"\"This method is similar to [tauri::generate_handler](https://docs.rs/tauri/latest/tauri/macro.generate_handler.html).\n\n    You can use this method to get `invoke_handler` for use with [BuilderArgs][pytauri.BuilderArgs].\n\n    Examples:\n        ```py\n        from anyio.from_thread import start_blocking_portal\n\n        commands = Commands()\n\n        with start_blocking_portal(backend) as portal:\n            invoke_handler = commands.generate_handler(portal)\n            ...\n        ```\n\n    !!! warning\n        The `portal` must remain valid while the returned `invoke_handler` is being used.\n    \"\"\"\n    async_invoke_handler = self._async_invoke_handler\n\n    def invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - `invoke_handler` must not raise exception\n        # - must not block\n\n        # this func will be call in extern thread, so it's ok to use `start_task_soon`\n        portal.start_task_soon(async_invoke_handler, invoke)\n\n    return invoke_handler\n</code></pre>"},{"location":"reference/pytauri/#pytauri.Commands.wrap_pyfunc","title":"wrap_pyfunc  <code>staticmethod</code>","text":"<pre><code>wrap_pyfunc(pyfunc: _WrappablePyHandlerType) -&gt; _PyHandlerType\n</code></pre> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <p>Specifically:</p> <ul> <li>If <code>pyfunc</code> has a <code>KEYWORD_ONLY</code> parameter named <code>body</code>, will check if <code>issubclass(body, BaseModel)</code> is true,   and if so, wrap it as a new function with <code>body: bytearray</code> parameter.</li> <li>If <code>pyfunc</code> conforms to <code>issubclass(return_annotation, BaseModel)</code>,   wrap it as a new function with <code>return_annotation: bytes</code> return type.</li> <li>If not, will return the original <code>pyfunc</code>.</li> </ul> <p>The <code>pyfunc</code> will be decorated using functools.wraps, and its <code>__signature__</code> will also be updated.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@staticmethod\ndef wrap_pyfunc(  # noqa: C901  # TODO: simplify the method\n    pyfunc: _WrappablePyHandlerType,\n) -&gt; _PyHandlerType:\n    \"\"\"Wrap a `Callable` to conform to the definition of PyHandlerType.\n\n    Specifically:\n\n    - If `pyfunc` has a `KEYWORD_ONLY` parameter named `body`, will check if `issubclass(body, BaseModel)` is true,\n      and if so, wrap it as a new function with `body: bytearray` parameter.\n    - If `pyfunc` conforms to `issubclass(return_annotation, BaseModel)`,\n      wrap it as a new function with `return_annotation: bytes` return type.\n    - If not, will return the original `pyfunc`.\n\n    The `pyfunc` will be decorated using [functools.wraps][], and its `__signature__` will also be updated.\n    \"\"\"\n    serializer = None\n    deserializer = None\n\n    body_key = \"body\"\n\n    sig = signature(pyfunc)\n    parameters = sig.parameters\n    return_annotation = sig.return_annotation\n\n    body_param = parameters.get(body_key)\n    if body_param is not None:\n        if body_param.kind not in {\n            body_param.KEYWORD_ONLY,\n            body_param.POSITIONAL_OR_KEYWORD,\n        }:\n            raise ValueError(f\"Expected `{body_key}` to be KEYWORD_ONLY\")\n        body_type = body_param.annotation\n        if issubclass(body_type, BaseModel):\n            serializer = body_type.model_validate_json\n        else:\n            if not issubclass(body_type, bytearray):\n                raise ValueError(\n                    f\"Expected `{body_key}` to be subclass of {BaseModel} or {bytearray}, \"\n                    f\"got {body_type}\"\n                )\n\n    if issubclass(return_annotation, BaseModel):\n        deserializer = return_annotation.__pydantic_serializer__.to_json\n    else:\n        if not issubclass(return_annotation, (bytes, bytearray)):\n            raise ValueError(\n                f\"Expected `return_annotation` to be subclass of {BaseModel}, {bytes} or {bytearray}, \"\n                f\"got {return_annotation}\"\n            )\n\n    if not serializer and not deserializer:\n        return cast(_PyHandlerType, pyfunc)  # `cast` make typing happy\n\n    @wraps(pyfunc)\n    async def wrapper(*args: Any, **kwargs: Any) -&gt; bytes:\n        nonlocal serializer, deserializer\n\n        if serializer is not None:\n            body_bytearray = kwargs[body_key]\n            assert isinstance(body_bytearray, bytearray)  # PERF\n            try:\n                body_model = serializer(body_bytearray)\n            except ValidationError as e:\n                raise InvokeException(str(e)) from e\n            kwargs[body_key] = body_model\n\n        resp = await pyfunc(*args, **kwargs)\n\n        if deserializer is not None:\n            assert isinstance(resp, BaseModel)  # PERF\n            return deserializer(resp)\n        else:\n            assert isinstance(resp, bytes)  # PERF\n            return resp\n\n    new_parameters = None\n    if serializer is not None:\n        new_parameters = parameters.copy()\n        new_parameters[body_key] = parameters[body_key].replace(\n            annotation=bytearray\n        )\n\n    # see: &lt;https://docs.python.org/3.13/library/inspect.html#inspect.signature&gt;\n    wrapper.__signature__ = (  # pyright: ignore[reportAttributeAccessIssue]\n        sig.replace(\n            parameters=list(new_parameters.values()),\n            return_annotation=bytes,\n        )\n        if new_parameters\n        else sig.replace(return_annotation=bytes)\n    )\n    return wrapper\n</code></pre>"},{"location":"reference/pytauri/#pytauri.Commands.parse_parameters","title":"parse_parameters  <code>staticmethod</code>","text":"<pre><code>parse_parameters(pyfunc: _PyHandlerType, /, check_signature: bool = True) -&gt; ParametersType\n</code></pre> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <p>Check if the Signature of <code>pyfunc</code> conforms to ArgumentsType, and if the return value is a subclass of bytes or bytearray.</p> <p>Parameters:</p> Name Type Description Default <code>_PyHandlerType</code> <p>The <code>Callable</code> to check.</p> required <code>bool</code> <p>Whether to check the signature of <code>pyfunc</code>. Set it to <code>False</code> only if you are sure that the signature conforms to the expected pattern.</p> <code>True</code> <p>Returns:</p> Type Description <code>ParametersType</code> <p>The parameters of the <code>pyfunc</code>. You can use it with Invoke.bind_to.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature does not conform to the expected pattern.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@staticmethod\ndef parse_parameters(\n    pyfunc: _PyHandlerType, /, check_signature: bool = True\n) -&gt; ParametersType:\n    \"\"\"Check the signature of a `Callable` and return the parameters.\n\n    Check if the [Signature][inspect.Signature] of `pyfunc` conforms to [ArgumentsType][pytauri.ipc.ArgumentsType],\n    and if the return value is a subclass of [bytes][] or [bytearray][].\n\n    Args:\n        pyfunc: The `Callable` to check.\n        check_signature: Whether to check the signature of `pyfunc`.\n            Set it to `False` only if you are sure that the signature conforms to the expected pattern.\n\n    Returns:\n        The parameters of the `pyfunc`. You can use it with [Invoke.bind_to][pytauri.ipc.Invoke.bind_to].\n\n    Raises:\n        ValueError: If the signature does not conform to the expected pattern.\n    \"\"\"\n    sig = signature(pyfunc)\n    parameters = sig.parameters\n    if not check_signature:\n        # `cast` make typing happy\n        return cast(ParametersType, parameters)\n\n    return_annotation = sig.return_annotation\n    checked_parameters: ParametersType = {}\n\n    arguments_type = {\n        \"body\": bytearray,\n        \"app_handle\": AppHandle,\n    }\n\n    for name, param in parameters.items():\n        correct_anna = arguments_type.get(name)\n        if correct_anna is None:\n            raise ValueError(\n                f\"Unexpected parameter `{name}`, expected one of {list(arguments_type.keys())}\"\n            )\n        if not issubclass(param.annotation, correct_anna):\n            raise ValueError(\n                f\"Expected `{name}` to be subclass of `{correct_anna}`, got `{param.annotation}`\"\n            )\n        checked_parameters[name] = param\n\n    if not issubclass(return_annotation, (bytes, bytearray)):\n        raise ValueError(\n            f\"Expected return_annotation to be subclass of {bytes} or {bytearray}, got `{return_annotation}`\"\n        )\n\n    return checked_parameters\n</code></pre>"},{"location":"reference/pytauri/#pytauri.Commands.parse_parameters(pyfunc)","title":"<code>pyfunc</code>","text":""},{"location":"reference/pytauri/#pytauri.Commands.parse_parameters(check_signature)","title":"<code>check_signature</code>","text":""},{"location":"reference/pytauri/#pytauri.Commands.set_command","title":"set_command","text":"<pre><code>set_command(command: str, handler: _WrappablePyHandlerType, /, check_signature: bool = True) -&gt; None\n</code></pre> <p>Set a command handler.</p> <p>This method internally calls parse_parameters and wrap_pyfunc, <code>parse_parameters(wrap_pyfunc(handler))</code>.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def set_command(\n    self,\n    command: str,\n    handler: _WrappablePyHandlerType,\n    /,\n    check_signature: bool = True,\n) -&gt; None:\n    \"\"\"Set a command handler.\n\n    This method internally calls [parse_parameters][pytauri.Commands.parse_parameters]\n    and [wrap_pyfunc][pytauri.Commands.wrap_pyfunc], `parse_parameters(wrap_pyfunc(handler))`.\n    \"\"\"\n    new_handler = self.wrap_pyfunc(handler)\n    parameters = self.parse_parameters(new_handler, check_signature=check_signature)\n    self.data[command] = _PyInvokHandleData(parameters, new_handler)\n</code></pre>"},{"location":"reference/pytauri/#pytauri.Commands.command","title":"command","text":"<pre><code>command(command: Optional[str] = None) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]\n</code></pre> <p>A decorator to register a command handler.</p> <p>Examples:</p> <pre><code>commands = Commands()\n\n\n@commands.command()\nasync def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n@commands.command(\"foo_command\")\nasync def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n</code></pre> <p>This method internally calls set_command, which means the function signature must conform to ArgumentsType.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[str]</code> <p>The name of the command. If not provided, the <code>__name__</code> of <code>callable</code> will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a command with the same name already exists. If it's expected, use set_command instead.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def command(\n    self, command: Optional[str] = None, /\n) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]:\n    \"\"\"A [decorator](https://docs.python.org/3/glossary.html#term-decorator) to register a command handler.\n\n    Examples:\n        ```py\n        commands = Commands()\n\n\n        @commands.command()\n        async def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n        @commands.command(\"foo_command\")\n        async def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n        ```\n\n    This method internally calls [set_command][pytauri.Commands.set_command],\n    which means the function signature must conform to [ArgumentsType][pytauri.ipc.ArgumentsType].\n\n    Args:\n        command: The name of the command. If not provided, the `__name__` of `callable` will be used.\n\n    Raises:\n        ValueError: If a command with the same name already exists.\n            If it's expected, use [set_command][pytauri.Commands.set_command] instead.\n    \"\"\"\n    if command is None:\n        return self._register\n    else:\n        return partial(self._register, command=command)\n</code></pre>"},{"location":"reference/pytauri/#pytauri.Commands.command(command)","title":"<code>command</code>","text":""},{"location":"reference/pytauri/#pytauri.builder_factory","title":"builder_factory","text":"<pre><code>builder_factory(*args: Any, **kwargs: Any) -&gt; Builder\n</code></pre> <p>A factory function for creating a <code>Builder</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def builder_factory(*args: Any, **kwargs: Any) -&gt; Builder:\n    \"\"\"A factory function for creating a `Builder` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/#pytauri.context_factory","title":"context_factory","text":"<pre><code>context_factory(*args: Any, **kwargs: Any) -&gt; Context\n</code></pre> <p>A factory function for creating a <code>Context</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def context_factory(*args: Any, **kwargs: Any) -&gt; Context:\n    \"\"\"A factory function for creating a `Context` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ipc/","title":"ipc","text":""},{"location":"reference/pytauri/ipc/#pytauri.ipc","title":"pytauri.ipc","text":"<p>tauri::ipc</p> <p>Classes:</p> Name Description <code>ArgumentsType</code> <p>The bound arguments of a command.</p> <code>Invoke</code> <p>tauri::ipc::Invoke</p> <code>InvokeResolver</code> <p>tauri::ipc::InvokeResolver</p> <code>ParametersType</code> <p>The parameters of a command.</p> <code>InvokeException</code> <p>Indicates that an exception occurred in a <code>command</code>. Similar to Rust's <code>Result::Err</code>.</p> <code>Commands</code> <p>This class provides features similar to tauri::generate_handler.</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ArgumentsType', 'Commands', 'Invoke', 'InvokeException', 'InvokeResolver', 'ParametersType']\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.ArgumentsType","title":"ArgumentsType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The bound arguments of a command.</p> <p>Each key is optional, depending on the keys of the bound ParametersType.</p> <p>You can use it like <code>**kwargs</code>, for example <code>command(**arguments)</code>.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>bytearray</code> <p>The body of ipc message.</p> <code>app_handle</code> <code>AppHandle</code> <p>The handle of the app.</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.ArgumentsType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: bytearray\n</code></pre> <p>The body of ipc message.</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.ArgumentsType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: AppHandle\n</code></pre> <p>The handle of the app.</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Invoke","title":"Invoke","text":"<p>tauri::ipc::Invoke</p> <p>Methods:</p> Name Description <code>bind_to</code> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <code>resolve</code> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>The name of the current command.</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Invoke.command","title":"command  <code>property</code>","text":"<pre><code>command: str\n</code></pre> <p>The name of the current command.</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Invoke.bind_to","title":"bind_to","text":"<pre><code>bind_to(parameters: ParametersType) -&gt; Optional[InvokeResolver[_ArgumentsTypeVar]]\n</code></pre> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <p>If the frontend illegally calls the IPC, this method will automatically reject this <code>Invoke</code> and return <code>None</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def bind_to(\n    self, parameters: ParametersType\n) -&gt; Optional[\"InvokeResolver[_ArgumentsTypeVar]\"]:\n    \"\"\"Consumes this `Invoke` and binds parameters.\n\n    If the frontend illegally calls the IPC,\n    this method will automatically reject this `Invoke` and return `None`.\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Invoke.resolve","title":"resolve","text":"<pre><code>resolve(value: Union[bytearray, bytes]) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: Union[bytearray, bytes]) -&gt; None:\n    \"\"\"Consumes this `Invoke` and resolves the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Invoke.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `Invoke` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.InvokeResolver","title":"InvokeResolver","text":"<p>               Bases: <code>Generic[_ArgumentsTypeVar]</code></p> <p>tauri::ipc::InvokeResolver</p> <p>Methods:</p> Name Description <code>resolve</code> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>arguments</code> <code>_ArgumentsTypeVar</code> <p>The bound arguments of the current command.</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.InvokeResolver.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: _ArgumentsTypeVar\n</code></pre> <p>The bound arguments of the current command.</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.InvokeResolver.resolve","title":"resolve","text":"<pre><code>resolve(value: Union[bytearray, bytes]) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: Union[bytearray, bytes]) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and resolves the command with the given value.\"\"\"\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.InvokeResolver.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.ParametersType","title":"ParametersType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The parameters of a command.</p> <p>All keys are optional, and values can be of any type. If a key exists, it will be assigned a value corresponding to ArgumentsType.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>ReadOnly[Any]</code> <p>whatever</p> <code>app_handle</code> <code>ReadOnly[Any]</code> <p>whatever</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.ParametersType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: ReadOnly[Any]\n</code></pre> <p>whatever</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.ParametersType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: ReadOnly[Any]\n</code></pre> <p>whatever</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.InvokeException","title":"InvokeException","text":"<pre><code>InvokeException(value: str)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Indicates that an exception occurred in a <code>command</code>. Similar to Rust's <code>Result::Err</code>.</p> <p>When this exception is raised in a <code>command</code>, pytauri will return it to the frontend through <code>Invoke.reject(value)</code> and will not log the exception on the python side.</p> <p>Attributes:</p> Name Type Description <code>value</code> <code>str</code> <p>The error message that will be returned to the frontend.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self, value: str) -&gt; None:  # noqa: D107\n    self.value = value\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.InvokeException.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value: str = value\n</code></pre> <p>The error message that will be returned to the frontend.</p>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Commands","title":"Commands","text":"<pre><code>Commands()\n</code></pre> <p>               Bases: <code>UserDict[str, _PyInvokHandleData]</code></p> <p>This class provides features similar to tauri::generate_handler.</p> <p>Typically, you would use Commands.command to register a command handler function. Then, use Commands.generate_handler to get an <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Methods:</p> Name Description <code>generate_handler</code> <p>This method is similar to tauri::generate_handler.</p> <code>wrap_pyfunc</code> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <code>parse_parameters</code> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <code>set_command</code> <p>Set a command handler.</p> <code>command</code> <p>A decorator to register a command handler.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def __init__(self) -&gt; None:  # noqa: D107\n    super().__init__()\n\n    data = self.data\n\n    async def _async_invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - the implementer of this function must not raise exceptions\n        # - and must ensure to fulfill `invoke/resolver`\n        resolver = None\n        try:\n            command = invoke.command\n            handler_data = data.get(command)\n            if handler_data is None:\n                invoke.reject(f\"no python handler `{command}` found\")\n                return\n\n            parameters = handler_data.parameters\n            handler = handler_data.handler\n\n            resolver = invoke.bind_to(parameters)\n            if resolver is None:\n                # `invoke` has already been rejected\n                return\n\n            try:\n                resp = await handler(**resolver.arguments)\n                # TODO, PERF: idk if this will block?\n            except InvokeException as e:\n                resolver.reject(e.value)\n            except Exception as e:\n                # # TODO: Should we return the traceback to the frontend?\n                # # It might leak information.\n                # from traceback import format_exc\n                # resolver.reject(format_exc())\n                _logger.exception(\n                    f\"invoke_handler {handler}: `{handler.__name__}` raised an exception\",\n                    exc_info=e,\n                )\n                resolver.reject(repr(e))\n            else:\n                resolver.resolve(resp)\n\n        except Exception as e:\n            msg = f\"{_async_invoke_handler} implementation raised an exception, please report this as a pytauri bug\"\n\n            _logger.critical(msg, exc_info=e)\n            if resolver is not None:\n                resolver.reject(msg)\n            else:\n                invoke.reject(msg)\n            raise\n\n    self._async_invoke_handler = _async_invoke_handler\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Commands.generate_handler","title":"generate_handler","text":"<pre><code>generate_handler(portal: BlockingPortal) -&gt; _InvokeHandlerProto\n</code></pre> <p>This method is similar to tauri::generate_handler.</p> <p>You can use this method to get <code>invoke_handler</code> for use with BuilderArgs.</p> <p>Examples:</p> <pre><code>from anyio.from_thread import start_blocking_portal\n\ncommands = Commands()\n\nwith start_blocking_portal(backend) as portal:\n    invoke_handler = commands.generate_handler(portal)\n    ...\n</code></pre> <p>Warning</p> <p>The <code>portal</code> must remain valid while the returned <code>invoke_handler</code> is being used.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def generate_handler(self, portal: BlockingPortal, /) -&gt; _InvokeHandlerProto:\n    \"\"\"This method is similar to [tauri::generate_handler](https://docs.rs/tauri/latest/tauri/macro.generate_handler.html).\n\n    You can use this method to get `invoke_handler` for use with [BuilderArgs][pytauri.BuilderArgs].\n\n    Examples:\n        ```py\n        from anyio.from_thread import start_blocking_portal\n\n        commands = Commands()\n\n        with start_blocking_portal(backend) as portal:\n            invoke_handler = commands.generate_handler(portal)\n            ...\n        ```\n\n    !!! warning\n        The `portal` must remain valid while the returned `invoke_handler` is being used.\n    \"\"\"\n    async_invoke_handler = self._async_invoke_handler\n\n    def invoke_handler(invoke: Invoke) -&gt; None:\n        # NOTE:\n        # - `invoke_handler` must not raise exception\n        # - must not block\n\n        # this func will be call in extern thread, so it's ok to use `start_task_soon`\n        portal.start_task_soon(async_invoke_handler, invoke)\n\n    return invoke_handler\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Commands.wrap_pyfunc","title":"wrap_pyfunc  <code>staticmethod</code>","text":"<pre><code>wrap_pyfunc(pyfunc: _WrappablePyHandlerType) -&gt; _PyHandlerType\n</code></pre> <p>Wrap a <code>Callable</code> to conform to the definition of PyHandlerType.</p> <p>Specifically:</p> <ul> <li>If <code>pyfunc</code> has a <code>KEYWORD_ONLY</code> parameter named <code>body</code>, will check if <code>issubclass(body, BaseModel)</code> is true,   and if so, wrap it as a new function with <code>body: bytearray</code> parameter.</li> <li>If <code>pyfunc</code> conforms to <code>issubclass(return_annotation, BaseModel)</code>,   wrap it as a new function with <code>return_annotation: bytes</code> return type.</li> <li>If not, will return the original <code>pyfunc</code>.</li> </ul> <p>The <code>pyfunc</code> will be decorated using functools.wraps, and its <code>__signature__</code> will also be updated.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@staticmethod\ndef wrap_pyfunc(  # noqa: C901  # TODO: simplify the method\n    pyfunc: _WrappablePyHandlerType,\n) -&gt; _PyHandlerType:\n    \"\"\"Wrap a `Callable` to conform to the definition of PyHandlerType.\n\n    Specifically:\n\n    - If `pyfunc` has a `KEYWORD_ONLY` parameter named `body`, will check if `issubclass(body, BaseModel)` is true,\n      and if so, wrap it as a new function with `body: bytearray` parameter.\n    - If `pyfunc` conforms to `issubclass(return_annotation, BaseModel)`,\n      wrap it as a new function with `return_annotation: bytes` return type.\n    - If not, will return the original `pyfunc`.\n\n    The `pyfunc` will be decorated using [functools.wraps][], and its `__signature__` will also be updated.\n    \"\"\"\n    serializer = None\n    deserializer = None\n\n    body_key = \"body\"\n\n    sig = signature(pyfunc)\n    parameters = sig.parameters\n    return_annotation = sig.return_annotation\n\n    body_param = parameters.get(body_key)\n    if body_param is not None:\n        if body_param.kind not in {\n            body_param.KEYWORD_ONLY,\n            body_param.POSITIONAL_OR_KEYWORD,\n        }:\n            raise ValueError(f\"Expected `{body_key}` to be KEYWORD_ONLY\")\n        body_type = body_param.annotation\n        if issubclass(body_type, BaseModel):\n            serializer = body_type.model_validate_json\n        else:\n            if not issubclass(body_type, bytearray):\n                raise ValueError(\n                    f\"Expected `{body_key}` to be subclass of {BaseModel} or {bytearray}, \"\n                    f\"got {body_type}\"\n                )\n\n    if issubclass(return_annotation, BaseModel):\n        deserializer = return_annotation.__pydantic_serializer__.to_json\n    else:\n        if not issubclass(return_annotation, (bytes, bytearray)):\n            raise ValueError(\n                f\"Expected `return_annotation` to be subclass of {BaseModel}, {bytes} or {bytearray}, \"\n                f\"got {return_annotation}\"\n            )\n\n    if not serializer and not deserializer:\n        return cast(_PyHandlerType, pyfunc)  # `cast` make typing happy\n\n    @wraps(pyfunc)\n    async def wrapper(*args: Any, **kwargs: Any) -&gt; bytes:\n        nonlocal serializer, deserializer\n\n        if serializer is not None:\n            body_bytearray = kwargs[body_key]\n            assert isinstance(body_bytearray, bytearray)  # PERF\n            try:\n                body_model = serializer(body_bytearray)\n            except ValidationError as e:\n                raise InvokeException(str(e)) from e\n            kwargs[body_key] = body_model\n\n        resp = await pyfunc(*args, **kwargs)\n\n        if deserializer is not None:\n            assert isinstance(resp, BaseModel)  # PERF\n            return deserializer(resp)\n        else:\n            assert isinstance(resp, bytes)  # PERF\n            return resp\n\n    new_parameters = None\n    if serializer is not None:\n        new_parameters = parameters.copy()\n        new_parameters[body_key] = parameters[body_key].replace(\n            annotation=bytearray\n        )\n\n    # see: &lt;https://docs.python.org/3.13/library/inspect.html#inspect.signature&gt;\n    wrapper.__signature__ = (  # pyright: ignore[reportAttributeAccessIssue]\n        sig.replace(\n            parameters=list(new_parameters.values()),\n            return_annotation=bytes,\n        )\n        if new_parameters\n        else sig.replace(return_annotation=bytes)\n    )\n    return wrapper\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Commands.parse_parameters","title":"parse_parameters  <code>staticmethod</code>","text":"<pre><code>parse_parameters(pyfunc: _PyHandlerType, /, check_signature: bool = True) -&gt; ParametersType\n</code></pre> <p>Check the signature of a <code>Callable</code> and return the parameters.</p> <p>Check if the Signature of <code>pyfunc</code> conforms to ArgumentsType, and if the return value is a subclass of bytes or bytearray.</p> <p>Parameters:</p> Name Type Description Default <code>_PyHandlerType</code> <p>The <code>Callable</code> to check.</p> required <code>bool</code> <p>Whether to check the signature of <code>pyfunc</code>. Set it to <code>False</code> only if you are sure that the signature conforms to the expected pattern.</p> <code>True</code> <p>Returns:</p> Type Description <code>ParametersType</code> <p>The parameters of the <code>pyfunc</code>. You can use it with Invoke.bind_to.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the signature does not conform to the expected pattern.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>@staticmethod\ndef parse_parameters(\n    pyfunc: _PyHandlerType, /, check_signature: bool = True\n) -&gt; ParametersType:\n    \"\"\"Check the signature of a `Callable` and return the parameters.\n\n    Check if the [Signature][inspect.Signature] of `pyfunc` conforms to [ArgumentsType][pytauri.ipc.ArgumentsType],\n    and if the return value is a subclass of [bytes][] or [bytearray][].\n\n    Args:\n        pyfunc: The `Callable` to check.\n        check_signature: Whether to check the signature of `pyfunc`.\n            Set it to `False` only if you are sure that the signature conforms to the expected pattern.\n\n    Returns:\n        The parameters of the `pyfunc`. You can use it with [Invoke.bind_to][pytauri.ipc.Invoke.bind_to].\n\n    Raises:\n        ValueError: If the signature does not conform to the expected pattern.\n    \"\"\"\n    sig = signature(pyfunc)\n    parameters = sig.parameters\n    if not check_signature:\n        # `cast` make typing happy\n        return cast(ParametersType, parameters)\n\n    return_annotation = sig.return_annotation\n    checked_parameters: ParametersType = {}\n\n    arguments_type = {\n        \"body\": bytearray,\n        \"app_handle\": AppHandle,\n    }\n\n    for name, param in parameters.items():\n        correct_anna = arguments_type.get(name)\n        if correct_anna is None:\n            raise ValueError(\n                f\"Unexpected parameter `{name}`, expected one of {list(arguments_type.keys())}\"\n            )\n        if not issubclass(param.annotation, correct_anna):\n            raise ValueError(\n                f\"Expected `{name}` to be subclass of `{correct_anna}`, got `{param.annotation}`\"\n            )\n        checked_parameters[name] = param\n\n    if not issubclass(return_annotation, (bytes, bytearray)):\n        raise ValueError(\n            f\"Expected return_annotation to be subclass of {bytes} or {bytearray}, got `{return_annotation}`\"\n        )\n\n    return checked_parameters\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Commands.parse_parameters(pyfunc)","title":"<code>pyfunc</code>","text":""},{"location":"reference/pytauri/ipc/#pytauri.ipc.Commands.parse_parameters(check_signature)","title":"<code>check_signature</code>","text":""},{"location":"reference/pytauri/ipc/#pytauri.ipc.Commands.set_command","title":"set_command","text":"<pre><code>set_command(command: str, handler: _WrappablePyHandlerType, /, check_signature: bool = True) -&gt; None\n</code></pre> <p>Set a command handler.</p> <p>This method internally calls parse_parameters and wrap_pyfunc, <code>parse_parameters(wrap_pyfunc(handler))</code>.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def set_command(\n    self,\n    command: str,\n    handler: _WrappablePyHandlerType,\n    /,\n    check_signature: bool = True,\n) -&gt; None:\n    \"\"\"Set a command handler.\n\n    This method internally calls [parse_parameters][pytauri.Commands.parse_parameters]\n    and [wrap_pyfunc][pytauri.Commands.wrap_pyfunc], `parse_parameters(wrap_pyfunc(handler))`.\n    \"\"\"\n    new_handler = self.wrap_pyfunc(handler)\n    parameters = self.parse_parameters(new_handler, check_signature=check_signature)\n    self.data[command] = _PyInvokHandleData(parameters, new_handler)\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Commands.command","title":"command","text":"<pre><code>command(command: Optional[str] = None) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]\n</code></pre> <p>A decorator to register a command handler.</p> <p>Examples:</p> <pre><code>commands = Commands()\n\n\n@commands.command()\nasync def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n@commands.command(\"foo_command\")\nasync def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n</code></pre> <p>This method internally calls set_command, which means the function signature must conform to ArgumentsType.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[str]</code> <p>The name of the command. If not provided, the <code>__name__</code> of <code>callable</code> will be used.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If a command with the same name already exists. If it's expected, use set_command instead.</p> Source code in <code>python/pytauri/src/pytauri/ipc.py</code> <pre><code>def command(\n    self, command: Optional[str] = None, /\n) -&gt; _RegisterType[_WrappablePyHandlerTypeVar]:\n    \"\"\"A [decorator](https://docs.python.org/3/glossary.html#term-decorator) to register a command handler.\n\n    Examples:\n        ```py\n        commands = Commands()\n\n\n        @commands.command()\n        async def my_command(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n\n\n        @commands.command(\"foo_command\")\n        async def my_command2(body: FooModel, app_handle: AppHandle) -&gt; BarModel: ...\n        ```\n\n    This method internally calls [set_command][pytauri.Commands.set_command],\n    which means the function signature must conform to [ArgumentsType][pytauri.ipc.ArgumentsType].\n\n    Args:\n        command: The name of the command. If not provided, the `__name__` of `callable` will be used.\n\n    Raises:\n        ValueError: If a command with the same name already exists.\n            If it's expected, use [set_command][pytauri.Commands.set_command] instead.\n    \"\"\"\n    if command is None:\n        return self._register\n    else:\n        return partial(self._register, command=command)\n</code></pre>"},{"location":"reference/pytauri/ipc/#pytauri.ipc.Commands.command(command)","title":"<code>command</code>","text":""},{"location":"reference/pytauri/ffi/","title":"ffi","text":""},{"location":"reference/pytauri/ffi/#pytauri.ffi","title":"pytauri.ffi","text":"<p>Original FFI interface module.</p> <p>Warning</p> <p>All APIs under this module should not be considered stable. You should use the re-exported APIs under the top-level module.</p> <p>Modules:</p> Name Description <code>ipc</code> <p>tauri::ipc</p> <code>lib</code> <p>tauri::self</p> <p>Classes:</p> Name Description <code>App</code> <p>Tauri::app</p> <code>AppHandle</code> <p>tauri::AppHandle</p> <code>Builder</code> <p>Tauri::Builder</p> <code>BuilderArgs</code> <code>Context</code> <p>tauri::Context</p> <code>RunEvent</code> <p>tauri::RunEvent</p> <code>RunEventEnum</code> <p>tauri::RunEvent</p> <p>Functions:</p> Name Description <code>builder_factory</code> <p>A factory function for creating a <code>Builder</code> instance.</p> <code>context_factory</code> <p>A factory function for creating a <code>Context</code> instance.</p> <p>Attributes:</p> Name Type Description <code>EXT_MOD</code> <code>ModuleType</code> <p>The extension module of <code>pytauri</code> app.</p> <code>RunEventEnumType</code> <code>TypeAlias</code> <p>See RunEventEnum for details.</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.EXT_MOD","title":"EXT_MOD  <code>module-attribute</code>","text":"<pre><code>EXT_MOD: ModuleType\n</code></pre> <p>The extension module of <code>pytauri</code> app.</p> <p>It will be loaded from <code>entry_points(group=\"pytauri\", name=\"ext_mod\")</code>.</p> <p>Usually you don't need to use it, unless you want to write plugins for <code>pytauri</code>.</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnumType","title":"RunEventEnumType  <code>module-attribute</code>","text":"<pre><code>RunEventEnumType: TypeAlias = Union[Exit, ExitRequested, WindowEvent, WebviewEvent, Ready, Resumed, MainEventsCleared, MenuEvent]\n</code></pre> <p>See RunEventEnum for details.</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ('EXT_MOD', 'App', 'AppHandle', 'Builder', 'BuilderArgs', 'Context', 'RunEvent', 'RunEventEnum', 'RunEventEnumType', 'builder_factory', 'context_factory')\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.App","title":"App","text":"<p>Tauri::app</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>run</code> <p>Consume and run this app, will block until the app is exited.</p> <code>run_iteration</code> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <code>cleanup_before_exit</code> <p>Runs necessary cleanup tasks before exiting the process.</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.App.run","title":"run","text":"<pre><code>run(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Consume and run this app, will block until the app is exited.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each event. It will be called on the same thread that the app was created on, so you should not block in this function.</p> <code>None</code> <p>Warning</p> <p>If <code>callback</code> is specified, it must not raise an exception, otherwise it is undefined behavior, and in most cases, the program will panic.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; None:\n    \"\"\"Consume and run this app, will block until the app is exited.\n\n    Args:\n        callback: a callback function that will be called on each event.\n            It will be called on the same thread that the app was created on,\n            so you should not block in this function.\n\n    !!! warning\n        If `callback` is specified, it must not raise an exception,\n        otherwise it is undefined behavior, and in most cases, the program will panic.\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.App.run(callback)","title":"<code>callback</code>","text":""},{"location":"reference/pytauri/ffi/#pytauri.ffi.App.run_iteration","title":"run_iteration","text":"<pre><code>run_iteration(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each iteration.</p> <code>None</code> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> <p>Tip</p> <p>Approximately 2ms per calling in debug mode.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_iteration(\n    self, callback: Optional[_AppRunCallbackType] = None, /\n) -&gt; None:\n    \"\"\"Run this app iteratively without consuming it, calling `callback` on each iteration.\n\n    Args:\n        callback: a callback function that will be called on each iteration.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n\n    !!! tip\n        Approximately 2ms per calling in debug mode.\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.App.run_iteration(callback)","title":"<code>callback</code>","text":""},{"location":"reference/pytauri/ffi/#pytauri.ffi.App.cleanup_before_exit","title":"cleanup_before_exit","text":"<pre><code>cleanup_before_exit() -&gt; None\n</code></pre> <p>Runs necessary cleanup tasks before exiting the process.</p> <p>You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def cleanup_before_exit(self, /) -&gt; None:\n    \"\"\"Runs necessary cleanup tasks before exiting the process.\n\n    **You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.**\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.AppHandle","title":"AppHandle","text":"<p>tauri::AppHandle</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.Builder","title":"Builder","text":"<p>Tauri::Builder</p> <p>use builder_factory to instantiate this class.</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>build</code> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.Builder.build","title":"build","text":"<pre><code>build(args: BuilderArgs) -&gt; App\n</code></pre> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def build(self, args: BuilderArgs, /) -&gt; App:\n    \"\"\"Consume this builder and build an app with the given `BuilderArgs`.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.BuilderArgs","title":"BuilderArgs","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>tauri::Builder</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.BuilderArgs.__new__","title":"__new__","text":"<pre><code>__new__(*, context: Context, invoke_handler: Optional[_InvokeHandlerProto] = None) -&gt; Self\n</code></pre> <p>tauri::Builder</p> <p>Warning</p> <p>The implementer of <code>invoke_handler</code> must never raise an exception, otherwise it is considered undefined behavior. Additionally, <code>invoke_handler</code> must not block.</p> <p>Parameters:</p> Name Type Description Default <code>Context</code> <p>use context_factory to get it.</p> required <code>Optional[_InvokeHandlerProto]</code> <p>use Commands to get it.</p> <code>None</code> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    context: \"Context\",\n    invoke_handler: Optional[_InvokeHandlerProto] = None,\n) -&gt; Self:\n    \"\"\"[tauri::Builder](https://docs.rs/tauri/latest/tauri/struct.Builder.html)\n\n    !!! warning\n        The implementer of `invoke_handler` must never raise an exception,\n        otherwise it is considered undefined behavior.\n        Additionally, `invoke_handler` must not block.\n\n    Args:\n        context: use [context_factory][pytauri.context_factory] to get it.\n        invoke_handler: use [Commands][pytauri.ipc.Commands] to get it.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.BuilderArgs.__new__(context)","title":"<code>context</code>","text":""},{"location":"reference/pytauri/ffi/#pytauri.ffi.BuilderArgs.__new__(invoke_handler)","title":"<code>invoke_handler</code>","text":""},{"location":"reference/pytauri/ffi/#pytauri.ffi.Context","title":"Context","text":"<p>tauri::Context</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEvent","title":"RunEvent","text":"<p>               Bases: <code>PyMatchRefMixin['RunEventEnumType']</code></p> <p>tauri::RunEvent</p> <p>Methods:</p> Name Description <code>match_ref</code> <p>Equivalent to <code>match &amp;self</code> in Rust.</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEvent.match_ref","title":"match_ref","text":"<pre><code>match_ref() -&gt; _T\n</code></pre> <p>Equivalent to <code>match &amp;self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_ref(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match &amp;self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum","title":"RunEventEnum","text":"<p>tauri::RunEvent</p> <p>Classes:</p> Name Description <code>Exit</code> <p>tauri::RunEvent::Exit</p> <code>ExitRequested</code> <p>tauri::RunEvent::ExitRequested</p> <code>WindowEvent</code> <p>tauri::RunEvent::WindowEvent</p> <code>WebviewEvent</code> <p>tauri::RunEvent::WebviewEvent</p> <code>Ready</code> <p>tauri::RunEvent::Ready</p> <code>Resumed</code> <p>tauri::RunEvent::Resumed</p> <code>MainEventsCleared</code> <p>tauri::RunEvent::MainEventsCleared</p> <code>MenuEvent</code> <p>tauri::RunEvent::MenuEvent</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.Exit","title":"Exit","text":"<p>tauri::RunEvent::Exit</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.ExitRequested","title":"ExitRequested","text":"<p>tauri::RunEvent::ExitRequested</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>Optional[int]</code>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.ExitRequested.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Optional[int]\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.WindowEvent","title":"WindowEvent","text":"<p>tauri::RunEvent::WindowEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.WindowEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::RunEvent::WebviewEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.WebviewEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.Ready","title":"Ready","text":"<p>tauri::RunEvent::Ready</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.Resumed","title":"Resumed","text":"<p>tauri::RunEvent::Resumed</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.MainEventsCleared","title":"MainEventsCleared","text":"<p>tauri::RunEvent::MainEventsCleared</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.RunEventEnum.MenuEvent","title":"MenuEvent","text":"<p>tauri::RunEvent::MenuEvent</p>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.builder_factory","title":"builder_factory","text":"<pre><code>builder_factory(*args: Any, **kwargs: Any) -&gt; Builder\n</code></pre> <p>A factory function for creating a <code>Builder</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def builder_factory(*args: Any, **kwargs: Any) -&gt; Builder:\n    \"\"\"A factory function for creating a `Builder` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/#pytauri.ffi.context_factory","title":"context_factory","text":"<pre><code>context_factory(*args: Any, **kwargs: Any) -&gt; Context\n</code></pre> <p>A factory function for creating a <code>Context</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def context_factory(*args: Any, **kwargs: Any) -&gt; Context:\n    \"\"\"A factory function for creating a `Context` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/ipc/","title":"ipc","text":""},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc","title":"pytauri.ffi.ipc","text":"<p>tauri::ipc</p> <p>Classes:</p> Name Description <code>ParametersType</code> <p>The parameters of a command.</p> <code>ArgumentsType</code> <p>The bound arguments of a command.</p> <code>Invoke</code> <p>tauri::ipc::Invoke</p> <code>InvokeResolver</code> <p>tauri::ipc::InvokeResolver</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ArgumentsType', 'Invoke', 'InvokeResolver', 'ParametersType']\n</code></pre>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType","title":"ParametersType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The parameters of a command.</p> <p>All keys are optional, and values can be of any type. If a key exists, it will be assigned a value corresponding to ArgumentsType.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>ReadOnly[Any]</code> <p>whatever</p> <code>app_handle</code> <code>ReadOnly[Any]</code> <p>whatever</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: ReadOnly[Any]\n</code></pre> <p>whatever</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.ParametersType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: ReadOnly[Any]\n</code></pre> <p>whatever</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType","title":"ArgumentsType","text":"<p>               Bases: <code>TypedDict</code></p> <p>The bound arguments of a command.</p> <p>Each key is optional, depending on the keys of the bound ParametersType.</p> <p>You can use it like <code>**kwargs</code>, for example <code>command(**arguments)</code>.</p> <p>Attributes:</p> Name Type Description <code>body</code> <code>bytearray</code> <p>The body of ipc message.</p> <code>app_handle</code> <code>AppHandle</code> <p>The handle of the app.</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType.body","title":"body  <code>instance-attribute</code>","text":"<pre><code>body: bytearray\n</code></pre> <p>The body of ipc message.</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.ArgumentsType.app_handle","title":"app_handle  <code>instance-attribute</code>","text":"<pre><code>app_handle: AppHandle\n</code></pre> <p>The handle of the app.</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke","title":"Invoke","text":"<p>tauri::ipc::Invoke</p> <p>Methods:</p> Name Description <code>bind_to</code> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <code>resolve</code> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>command</code> <code>str</code> <p>The name of the current command.</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.command","title":"command  <code>property</code>","text":"<pre><code>command: str\n</code></pre> <p>The name of the current command.</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.bind_to","title":"bind_to","text":"<pre><code>bind_to(parameters: ParametersType) -&gt; Optional[InvokeResolver[_ArgumentsTypeVar]]\n</code></pre> <p>Consumes this <code>Invoke</code> and binds parameters.</p> <p>If the frontend illegally calls the IPC, this method will automatically reject this <code>Invoke</code> and return <code>None</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def bind_to(\n    self, parameters: ParametersType\n) -&gt; Optional[\"InvokeResolver[_ArgumentsTypeVar]\"]:\n    \"\"\"Consumes this `Invoke` and binds parameters.\n\n    If the frontend illegally calls the IPC,\n    this method will automatically reject this `Invoke` and return `None`.\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.resolve","title":"resolve","text":"<pre><code>resolve(value: Union[bytearray, bytes]) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and resolves the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: Union[bytearray, bytes]) -&gt; None:\n    \"\"\"Consumes this `Invoke` and resolves the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.Invoke.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>Invoke</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `Invoke` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver","title":"InvokeResolver","text":"<p>               Bases: <code>Generic[_ArgumentsTypeVar]</code></p> <p>tauri::ipc::InvokeResolver</p> <p>Methods:</p> Name Description <code>resolve</code> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> <code>reject</code> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> <p>Attributes:</p> Name Type Description <code>arguments</code> <code>_ArgumentsTypeVar</code> <p>The bound arguments of the current command.</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver.arguments","title":"arguments  <code>property</code>","text":"<pre><code>arguments: _ArgumentsTypeVar\n</code></pre> <p>The bound arguments of the current command.</p>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver.resolve","title":"resolve","text":"<pre><code>resolve(value: Union[bytearray, bytes]) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and resolves the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def resolve(self, value: Union[bytearray, bytes]) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and resolves the command with the given value.\"\"\"\n</code></pre>"},{"location":"reference/pytauri/ffi/ipc/#pytauri.ffi.ipc.InvokeResolver.reject","title":"reject","text":"<pre><code>reject(value: str) -&gt; None\n</code></pre> <p>Consumes this <code>InvokeResolver</code> and rejects the command with the given value.</p> Source code in <code>python/pytauri/src/pytauri/ffi/ipc.py</code> <pre><code>def reject(self, value: str) -&gt; None:\n    \"\"\"Consumes this `InvokeResolver` and rejects the command with the given value.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/","title":"lib","text":""},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib","title":"pytauri.ffi.lib","text":"<p>tauri::self</p> <p>Classes:</p> Name Description <code>App</code> <p>Tauri::app</p> <code>AppHandle</code> <p>tauri::AppHandle</p> <code>BuilderArgs</code> <code>Builder</code> <p>Tauri::Builder</p> <code>Context</code> <p>tauri::Context</p> <code>RunEvent</code> <p>tauri::RunEvent</p> <code>RunEventEnum</code> <p>tauri::RunEvent</p> <p>Functions:</p> Name Description <code>builder_factory</code> <p>A factory function for creating a <code>Builder</code> instance.</p> <code>context_factory</code> <p>A factory function for creating a <code>Context</code> instance.</p> <p>Attributes:</p> Name Type Description <code>RunEventEnumType</code> <code>TypeAlias</code> <p>See RunEventEnum for details.</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['App', 'AppHandle', 'Builder', 'BuilderArgs', 'Context', 'RunEvent', 'RunEventEnum', 'RunEventEnumType', 'builder_factory', 'context_factory']\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnumType","title":"RunEventEnumType  <code>module-attribute</code>","text":"<pre><code>RunEventEnumType: TypeAlias = Union[Exit, ExitRequested, WindowEvent, WebviewEvent, Ready, Resumed, MainEventsCleared, MenuEvent]\n</code></pre> <p>See RunEventEnum for details.</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.App","title":"App","text":"<p>Tauri::app</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>run</code> <p>Consume and run this app, will block until the app is exited.</p> <code>run_iteration</code> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <code>cleanup_before_exit</code> <p>Runs necessary cleanup tasks before exiting the process.</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.App.run","title":"run","text":"<pre><code>run(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Consume and run this app, will block until the app is exited.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each event. It will be called on the same thread that the app was created on, so you should not block in this function.</p> <code>None</code> <p>Warning</p> <p>If <code>callback</code> is specified, it must not raise an exception, otherwise it is undefined behavior, and in most cases, the program will panic.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run(self, callback: Optional[_AppRunCallbackType] = None, /) -&gt; None:\n    \"\"\"Consume and run this app, will block until the app is exited.\n\n    Args:\n        callback: a callback function that will be called on each event.\n            It will be called on the same thread that the app was created on,\n            so you should not block in this function.\n\n    !!! warning\n        If `callback` is specified, it must not raise an exception,\n        otherwise it is undefined behavior, and in most cases, the program will panic.\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.App.run(callback)","title":"<code>callback</code>","text":""},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.App.run_iteration","title":"run_iteration","text":"<pre><code>run_iteration(callback: Optional[_AppRunCallbackType] = None) -&gt; None\n</code></pre> <p>Run this app iteratively without consuming it, calling <code>callback</code> on each iteration.</p> <p>Parameters:</p> Name Type Description Default <code>Optional[_AppRunCallbackType]</code> <p>a callback function that will be called on each iteration.</p> <code>None</code> <p>Warning</p> <p><code>callback</code> has the same restrictions as App.run.</p> <p>Tip</p> <p>Approximately 2ms per calling in debug mode.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def run_iteration(\n    self, callback: Optional[_AppRunCallbackType] = None, /\n) -&gt; None:\n    \"\"\"Run this app iteratively without consuming it, calling `callback` on each iteration.\n\n    Args:\n        callback: a callback function that will be called on each iteration.\n\n    !!! warning\n        `callback` has the same restrictions as [App.run][pytauri.App.run].\n\n    !!! tip\n        Approximately 2ms per calling in debug mode.\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.App.run_iteration(callback)","title":"<code>callback</code>","text":""},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.App.cleanup_before_exit","title":"cleanup_before_exit","text":"<pre><code>cleanup_before_exit() -&gt; None\n</code></pre> <p>Runs necessary cleanup tasks before exiting the process.</p> <p>You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def cleanup_before_exit(self, /) -&gt; None:\n    \"\"\"Runs necessary cleanup tasks before exiting the process.\n\n    **You should always exit the tauri app immediately after this function returns and not use any tauri-related APIs.**\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.AppHandle","title":"AppHandle","text":"<p>tauri::AppHandle</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs","title":"BuilderArgs","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>tauri::Builder</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs.__new__","title":"__new__","text":"<pre><code>__new__(*, context: Context, invoke_handler: Optional[_InvokeHandlerProto] = None) -&gt; Self\n</code></pre> <p>tauri::Builder</p> <p>Warning</p> <p>The implementer of <code>invoke_handler</code> must never raise an exception, otherwise it is considered undefined behavior. Additionally, <code>invoke_handler</code> must not block.</p> <p>Parameters:</p> Name Type Description Default <code>Context</code> <p>use context_factory to get it.</p> required <code>Optional[_InvokeHandlerProto]</code> <p>use Commands to get it.</p> <code>None</code> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def __new__(\n    cls,\n    /,\n    *,\n    context: \"Context\",\n    invoke_handler: Optional[_InvokeHandlerProto] = None,\n) -&gt; Self:\n    \"\"\"[tauri::Builder](https://docs.rs/tauri/latest/tauri/struct.Builder.html)\n\n    !!! warning\n        The implementer of `invoke_handler` must never raise an exception,\n        otherwise it is considered undefined behavior.\n        Additionally, `invoke_handler` must not block.\n\n    Args:\n        context: use [context_factory][pytauri.context_factory] to get it.\n        invoke_handler: use [Commands][pytauri.ipc.Commands] to get it.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs.__new__(context)","title":"<code>context</code>","text":""},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.BuilderArgs.__new__(invoke_handler)","title":"<code>invoke_handler</code>","text":""},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.Builder","title":"Builder","text":"<p>Tauri::Builder</p> <p>use builder_factory to instantiate this class.</p> <p>Warning</p> <p>This class is not thread-safe, and should not be shared between threads.</p> <ul> <li>You can only use it on the thread it was created on.</li> <li>And you need to ensure it is garbage collected on the thread it was created on,     otherwise it will cause memory leaks.</li> </ul> <p>Methods:</p> Name Description <code>build</code> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.Builder.build","title":"build","text":"<pre><code>build(args: BuilderArgs) -&gt; App\n</code></pre> <p>Consume this builder and build an app with the given <code>BuilderArgs</code>.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def build(self, args: BuilderArgs, /) -&gt; App:\n    \"\"\"Consume this builder and build an app with the given `BuilderArgs`.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.Context","title":"Context","text":"<p>tauri::Context</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent","title":"RunEvent","text":"<p>               Bases: <code>PyMatchRefMixin['RunEventEnumType']</code></p> <p>tauri::RunEvent</p> <p>Methods:</p> Name Description <code>match_ref</code> <p>Equivalent to <code>match &amp;self</code> in Rust.</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEvent.match_ref","title":"match_ref","text":"<pre><code>match_ref() -&gt; _T\n</code></pre> <p>Equivalent to <code>match &amp;self</code> in Rust.</p> Source code in <code>python/pyo3-utils/src/pyo3_utils/__init__.py</code> <pre><code>def match_ref(self, /) -&gt; _T:\n    \"\"\"Equivalent to `match &amp;self` in Rust.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum","title":"RunEventEnum","text":"<p>tauri::RunEvent</p> <p>Classes:</p> Name Description <code>Exit</code> <p>tauri::RunEvent::Exit</p> <code>ExitRequested</code> <p>tauri::RunEvent::ExitRequested</p> <code>WindowEvent</code> <p>tauri::RunEvent::WindowEvent</p> <code>WebviewEvent</code> <p>tauri::RunEvent::WebviewEvent</p> <code>Ready</code> <p>tauri::RunEvent::Ready</p> <code>Resumed</code> <p>tauri::RunEvent::Resumed</p> <code>MainEventsCleared</code> <p>tauri::RunEvent::MainEventsCleared</p> <code>MenuEvent</code> <p>tauri::RunEvent::MenuEvent</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.Exit","title":"Exit","text":"<p>tauri::RunEvent::Exit</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.ExitRequested","title":"ExitRequested","text":"<p>tauri::RunEvent::ExitRequested</p> <p>Attributes:</p> Name Type Description <code>code</code> <code>Optional[int]</code>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.ExitRequested.code","title":"code  <code>instance-attribute</code>","text":"<pre><code>code: Optional[int]\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.WindowEvent","title":"WindowEvent","text":"<p>tauri::RunEvent::WindowEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.WindowEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.WebviewEvent","title":"WebviewEvent","text":"<p>tauri::RunEvent::WebviewEvent</p> <p>Attributes:</p> Name Type Description <code>label</code> <code>str</code>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.WebviewEvent.label","title":"label  <code>instance-attribute</code>","text":"<pre><code>label: str\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.Ready","title":"Ready","text":"<p>tauri::RunEvent::Ready</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.Resumed","title":"Resumed","text":"<p>tauri::RunEvent::Resumed</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.MainEventsCleared","title":"MainEventsCleared","text":"<p>tauri::RunEvent::MainEventsCleared</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.RunEventEnum.MenuEvent","title":"MenuEvent","text":"<p>tauri::RunEvent::MenuEvent</p>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.builder_factory","title":"builder_factory","text":"<pre><code>builder_factory(*args: Any, **kwargs: Any) -&gt; Builder\n</code></pre> <p>A factory function for creating a <code>Builder</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def builder_factory(*args: Any, **kwargs: Any) -&gt; Builder:\n    \"\"\"A factory function for creating a `Builder` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri/ffi/lib/#pytauri.ffi.lib.context_factory","title":"context_factory","text":"<pre><code>context_factory(*args: Any, **kwargs: Any) -&gt; Context\n</code></pre> <p>A factory function for creating a <code>Context</code> instance.</p> <p>This is the closure passed from the Rust side when initializing the pytauri pyo3 module. <code>args</code> and <code>kwargs</code> will be passed to this closure.</p> Source code in <code>python/pytauri/src/pytauri/ffi/lib.py</code> <pre><code>def context_factory(*args: Any, **kwargs: Any) -&gt; Context:\n    \"\"\"A factory function for creating a `Context` instance.\n\n    This is the closure passed from the Rust side when initializing the pytauri pyo3 module.\n    `args` and `kwargs` will be passed to this closure.\n    \"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri_plugin_notification/","title":"pytauri_plugin_notification","text":""},{"location":"reference/pytauri_plugin_notification/#pytauri_plugin_notification","title":"pytauri_plugin_notification","text":"<p>tauri_plugin_notification::self</p> <p>Modules:</p> Name Description <code>ffi</code> <p>Original FFI interface module.</p> <p>Classes:</p> Name Description <code>NotificationBuilder</code> <p>tauri_plugin_notification::NotificationBuilder</p> <code>NotificationBuilderArgs</code> <code>NotificationExt</code> <p>tauri_plugin_notification::NotificationExt</p> <p>Attributes:</p> Name Type Description <code>ImplNotificationExt</code> <code>TypeAlias</code> <p>The implementors of <code>NotificationExt</code>.</p>"},{"location":"reference/pytauri_plugin_notification/#pytauri_plugin_notification.ImplNotificationExt","title":"ImplNotificationExt  <code>module-attribute</code>","text":"<pre><code>ImplNotificationExt: TypeAlias = Union[App, AppHandle]\n</code></pre> <p>The implementors of <code>NotificationExt</code>.</p>"},{"location":"reference/pytauri_plugin_notification/#pytauri_plugin_notification.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ImplNotificationExt', 'NotificationBuilder', 'NotificationBuilderArgs', 'NotificationExt']\n</code></pre>"},{"location":"reference/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationBuilder","title":"NotificationBuilder","text":"<p>tauri_plugin_notification::NotificationBuilder</p> <p>Methods:</p> Name Description <code>show</code> <p>Consume this builder and show the notification.</p>"},{"location":"reference/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationBuilder.show","title":"show","text":"<pre><code>show(args: NotificationBuilderArgs) -&gt; None\n</code></pre> <p>Consume this builder and show the notification.</p>"},{"location":"reference/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationBuilder.show--fixme-xxx-todo","title":"FIXME, XXX, TODO:","text":"<p>See: https://github.com/tauri-apps/tauri/issues/3700</p> <p>On windows, you must install the package via the <code>.msi</code> or <code>nsis</code>, or <code>tauri-plugin-notification</code> will not work.</p> <p>Tracker issue: https://github.com/tauri-apps/plugins-workspace/issues/2156</p> Source code in <code>python/pytauri-plugin-notification/src/pytauri_plugin_notification/ffi.py</code> <pre><code>def show(self, args: NotificationBuilderArgs, /) -&gt; None:\n    \"\"\"Consume this builder and show the notification.\n\n    # FIXME, XXX, TODO:\n\n    See: &lt;https://github.com/tauri-apps/tauri/issues/3700&gt;\n\n    On windows, you must install the package via the `.msi` or `nsis`, or `tauri-plugin-notification` will not work.\n\n    Tracker issue: &lt;https://github.com/tauri-apps/plugins-workspace/issues/2156&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationBuilderArgs","title":"NotificationBuilderArgs","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>tauri_plugin_notification::NotificationBuilder</p>"},{"location":"reference/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationBuilderArgs.__new__","title":"__new__","text":"<pre><code>__new__(*, title: Optional[str] = None, body: Optional[str] = None) -&gt; Self\n</code></pre> <p>tauri_plugin_notification::NotificationBuilder</p> Source code in <code>python/pytauri-plugin-notification/src/pytauri_plugin_notification/ffi.py</code> <pre><code>def __new__(\n    cls, /, *, title: Optional[str] = None, body: Optional[str] = None\n) -&gt; Self:\n    \"\"\"[tauri_plugin_notification::NotificationBuilder](https://docs.rs/tauri-plugin-notification/latest/tauri_plugin_notification/struct.NotificationBuilder.html)\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationExt","title":"NotificationExt","text":"<p>tauri_plugin_notification::NotificationExt</p> <p>Methods:</p> Name Description <code>builder</code> <p>Create a new notification builder.</p>"},{"location":"reference/pytauri_plugin_notification/#pytauri_plugin_notification.NotificationExt.builder","title":"builder  <code>staticmethod</code>","text":"<pre><code>builder(slf: ImplNotificationExt) -&gt; NotificationBuilder\n</code></pre> <p>Create a new notification builder.</p> Source code in <code>python/pytauri-plugin-notification/src/pytauri_plugin_notification/ffi.py</code> <pre><code>@staticmethod\ndef builder(slf: \"ImplNotificationExt\", /) -&gt; NotificationBuilder:\n    \"\"\"Create a new notification builder.\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri_plugin_notification/ffi/","title":"ffi","text":""},{"location":"reference/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi","title":"pytauri_plugin_notification.ffi","text":"<p>Original FFI interface module.</p> <p>Warning</p> <p>All APIs under this module should not be considered stable. You should use the re-exported APIs under the top-level module.</p> <p>Classes:</p> Name Description <code>NotificationBuilderArgs</code> <code>NotificationBuilder</code> <p>tauri_plugin_notification::NotificationBuilder</p> <code>NotificationExt</code> <p>tauri_plugin_notification::NotificationExt</p> <p>Attributes:</p> Name Type Description <code>ImplNotificationExt</code> <code>TypeAlias</code> <p>The implementors of <code>NotificationExt</code>.</p>"},{"location":"reference/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.__all__","title":"__all__  <code>module-attribute</code>","text":"<pre><code>__all__ = ['ImplNotificationExt', 'NotificationBuilder', 'NotificationBuilderArgs', 'NotificationExt']\n</code></pre>"},{"location":"reference/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.ImplNotificationExt","title":"ImplNotificationExt  <code>module-attribute</code>","text":"<pre><code>ImplNotificationExt: TypeAlias = Union[App, AppHandle]\n</code></pre> <p>The implementors of <code>NotificationExt</code>.</p>"},{"location":"reference/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationBuilderArgs","title":"NotificationBuilderArgs","text":"<p>Methods:</p> Name Description <code>__new__</code> <p>tauri_plugin_notification::NotificationBuilder</p>"},{"location":"reference/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationBuilderArgs.__new__","title":"__new__","text":"<pre><code>__new__(*, title: Optional[str] = None, body: Optional[str] = None) -&gt; Self\n</code></pre> <p>tauri_plugin_notification::NotificationBuilder</p> Source code in <code>python/pytauri-plugin-notification/src/pytauri_plugin_notification/ffi.py</code> <pre><code>def __new__(\n    cls, /, *, title: Optional[str] = None, body: Optional[str] = None\n) -&gt; Self:\n    \"\"\"[tauri_plugin_notification::NotificationBuilder](https://docs.rs/tauri-plugin-notification/latest/tauri_plugin_notification/struct.NotificationBuilder.html)\"\"\"\n    ...\n</code></pre>"},{"location":"reference/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationBuilder","title":"NotificationBuilder","text":"<p>tauri_plugin_notification::NotificationBuilder</p> <p>Methods:</p> Name Description <code>show</code> <p>Consume this builder and show the notification.</p>"},{"location":"reference/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationBuilder.show","title":"show","text":"<pre><code>show(args: NotificationBuilderArgs) -&gt; None\n</code></pre> <p>Consume this builder and show the notification.</p>"},{"location":"reference/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationBuilder.show--fixme-xxx-todo","title":"FIXME, XXX, TODO:","text":"<p>See: https://github.com/tauri-apps/tauri/issues/3700</p> <p>On windows, you must install the package via the <code>.msi</code> or <code>nsis</code>, or <code>tauri-plugin-notification</code> will not work.</p> <p>Tracker issue: https://github.com/tauri-apps/plugins-workspace/issues/2156</p> Source code in <code>python/pytauri-plugin-notification/src/pytauri_plugin_notification/ffi.py</code> <pre><code>def show(self, args: NotificationBuilderArgs, /) -&gt; None:\n    \"\"\"Consume this builder and show the notification.\n\n    # FIXME, XXX, TODO:\n\n    See: &lt;https://github.com/tauri-apps/tauri/issues/3700&gt;\n\n    On windows, you must install the package via the `.msi` or `nsis`, or `tauri-plugin-notification` will not work.\n\n    Tracker issue: &lt;https://github.com/tauri-apps/plugins-workspace/issues/2156&gt;\n    \"\"\"\n</code></pre>"},{"location":"reference/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationExt","title":"NotificationExt","text":"<p>tauri_plugin_notification::NotificationExt</p> <p>Methods:</p> Name Description <code>builder</code> <p>Create a new notification builder.</p>"},{"location":"reference/pytauri_plugin_notification/ffi/#pytauri_plugin_notification.ffi.NotificationExt.builder","title":"builder  <code>staticmethod</code>","text":"<pre><code>builder(slf: ImplNotificationExt) -&gt; NotificationBuilder\n</code></pre> <p>Create a new notification builder.</p> Source code in <code>python/pytauri-plugin-notification/src/pytauri_plugin_notification/ffi.py</code> <pre><code>@staticmethod\ndef builder(slf: \"ImplNotificationExt\", /) -&gt; NotificationBuilder:\n    \"\"\"Create a new notification builder.\"\"\"\n    ...\n</code></pre>"},{"location":"usage/concepts/ipc/","title":"IPC Commands","text":"<p>ref:</p> <ul> <li>pytauri.ipc.Commands</li> <li>https://tauri.app/develop/calling-rust/</li> </ul> <p>TODO</p>"},{"location":"usage/tutorial/","title":"Prerequisites","text":""},{"location":"usage/tutorial/#platforms","title":"Platforms","text":"<ul> <li>Tier 1: my(author's) primary development environment<ul> <li>Windows 10</li> </ul> </li> <li>Tier 2: will got bugs fixed and tested on ci<ul> <li>Linux (WSL2)</li> </ul> </li> <li>Tier 3: will not be tested, may not work<ul> <li>MacOS</li> <li>Windows 7</li> </ul> </li> </ul> <p>Info</p> <p>I do not have MacOS, so I cannot debug issues on MacOS. That is why it is in Tier 3.</p> <p>If you would like better support for MacOS, please consider becoming a maintainer.</p>"},{"location":"usage/tutorial/#python","title":"Python","text":"<p>We support all Python versions that are currently in their lifecycle. The current version is <code>&gt;= 3.9</code>.</p> <p>https://www.python.org/downloads/</p> <p>Warning</p> <p>For linux development, you need to ensure that your Python installation contains a shared library.</p> <p>To install the Python shared library on Ubuntu: <code>sudo apt install python3-dev</code>.</p> <p>To install the Python shared library on RPM based distributions (e.g. Fedora, Red Hat, SuSE), install the <code>python3-devel</code> package.</p>"},{"location":"usage/tutorial/#rust","title":"Rust","text":"<p>The latest stable version.</p> <p>https://www.rust-lang.org/tools/install</p> <p>for python developers</p> <p>You can upgrade your existing Rust version by running <code>rustup update stable</code>.</p>"},{"location":"usage/tutorial/#system-dependencies","title":"System Dependencies","text":"<ul> <li>Tauri Prerequisites</li> </ul>"},{"location":"usage/tutorial/build-sdist/","title":"Build python source (sdist) distribution","text":""},{"location":"usage/tutorial/build-sdist/#setuptools-rust","title":"setuptools-rust","text":"<p>When you want to distribute your app in Python format, you need to compile pytauri into a Python extension module file, instead of providing it in memory through <code>pytauri::standalone::append_ext_mod</code> in the <code>main.rs</code> executable.</p> <p>To do this, we need to use setuptools-rust.</p> <p>Add it to <code>[build-system]</code>:</p> src-tauri/pyproject.toml<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61\", \"setuptools-rust==1.*\"]\nbuild-backend = \"setuptools.build_meta\"\n</code></pre> <p>And add the following file:</p> src-tauri/setup.py<pre><code>\"\"\"See: &lt;https://setuptools-rust.readthedocs.io/en/latest/setuppy_tutorial.html&gt;\"\"\"\n\nfrom os import getenv\n\nfrom setuptools import setup\nfrom setuptools_rust import RustExtension\n\nPYTAURI_STANDALONE = getenv(\"PYTAURI_STANDALONE\") == \"1\"\n\"\"\"Instead of building pytauri as an extension module file, it will be loaded in memory through Rust's `append_ext_mod`\"\"\"\n\nsetup(\n    rust_extensions=[\n        RustExtension(\n            # set `target` the same as `[project.entry-points.pytauri.ext_mod]` in `pyproject.toml`\n            target=\"tauri_app.ext_mod\",\n            # It is recommended to set other features in `Cargo.toml`, except the following features:\n            features=[\n                # see: &lt;https://pyo3.rs/v0.23.3/building-and-distribution.html#the-extension-module-feature&gt;,\n                # required to build the extension module\n                \"pyo3/extension-module\",\n                # This feature tells Tauri to use embedded frontend assets instead of using a frontend development server.\n                # Usually, this feature is enabled by `tauri-cli`, here we enable it manually.\n                \"tauri/custom-protocol\",\n            ],\n        )\n    ]\n    if not PYTAURI_STANDALONE\n    else [],\n)\n</code></pre>"},{"location":"usage/tutorial/build-sdist/#include-frontend-assets","title":"Include frontend assets","text":"<p>You need to include the frontend assets in the sdist so that users can build your app from the source.</p> <p>Configure Vite to output the frontend assets to <code>src-tauri/frontend</code>:</p> vite.config.ts<pre><code>// https://vitejs.dev/config/\nexport default defineConfig(async () =&gt; ({\n  build: {\n    // build dist into `src-tauri/` so that we can include it in Python sdist\n    outDir: \"src-tauri/frontend\",\n  },\n}));\n</code></pre> <p>Also, let tauri-cli know where the frontend assets are:</p> src-tauri/tauri.conf.json<pre><code>{\n  \"build\": {\n    \"frontendDist\": \"./frontend\"\n  },\n}\n</code></pre> <p>Include the frontend assets in the sdist:</p> <p>ref: https://setuptools.pypa.io/en/latest/userguide/miscellaneous.html</p> src-tauri/MANIFEST.in<pre><code>graft frontend/\n</code></pre>"},{"location":"usage/tutorial/build-sdist/#include-rust-files","title":"Include rust files","text":"<p>You will also need to tell Setuptools that the Rust files are required to build your project from the source distribution. That can be done either via <code>MANIFEST.in</code> or via a plugin like setuptools-scm.</p> setuptools-scmMANIFEST.in <p>Use <code>setuptools-scm</code> to include all files tracked by <code>git</code> (just add it as a dependency):</p> src-tauri/pyproject.toml<pre><code>[build-system]\nrequires = [\"setuptools&gt;=61\", \"setuptools-rust==1.*\", \"setuptools_scm&gt;=8\"]\nbuild-backend = \"setuptools.build_meta\"\n</code></pre> <p>Info</p> <p>Normally, we do not track <code>src-tauri/frontend</code>, which is why we use <code>MANIFEST.in</code> to include it.</p> src-tauri/MANIFEST.in<pre><code>graft frontend/\ngraft capabilities/\ngraft icons/\ngraft src/\ninclude Cargo.toml\ninclude Cargo.lock\ninclude build.rs\ninclude tauri.conf.json\n</code></pre>"},{"location":"usage/tutorial/build-sdist/#build-sdist","title":"Build sdist","text":"<ul> <li> <p>Build frontend assets first: <code>pnpm build</code> (see <code>build.beforeBuildCommand</code> in <code>tau.conf.json</code>).</p> </li> <li> <p>Now you can build only sdist: <code>uv build src-tauri --sdist</code>.</p> <ul> <li>Or build both wheel and sdist: <code>uv build src-tauri</code>.</li> </ul> <p>Tip</p> <p>As long as you can build the wheel with <code>uv build src-tauri</code>, it means your Python sdist can be used normally. Otherwise, you might have forgotten to include some Rust files.</p> </li> </ul>"},{"location":"usage/tutorial/build-standalone/","title":"Build standalone binary","text":"<p>pytauri can be distributed as a Python wheel or compiled into a standalone executable (a regular Tauri application).</p> <p>Unlike packaging with <code>pyinstaller</code> after building as a wheel, compiling pytauri into an executable allows you to enjoy all the benefits brought by <code>tauri-cli</code>.</p>"},{"location":"usage/tutorial/build-standalone/#get-portable-python","title":"Get portable Python","text":"<p>We will bundle python-build-standalone as a portable Python for distribution.</p> <p>Please download the Python version you need. Usually, you will use these versions:</p> <ul> <li><code>cpython-*-x86_64-pc-windows-msvc-install_only_stripped.tar.gz</code></li> <li><code>cpython-*-x86_64-unknown-linux-gnu-install_only_stripped.tar.gz</code></li> <li><code>cpython-*-x86_64-apple-darwin-install_only_stripped.tar.gz</code></li> </ul> <p>Extract it to <code>src-tauri/pyembed</code>, make sure the file layout is as follows:</p> windowsunix <pre><code>\u251c\u2500\u2500 src-tauri/pyembed/python\n    \u251c\u2500\u2500 python.exe\n    \u251c\u2500\u2500 python3.dll\n    \u2514\u2500\u2500 ...\n</code></pre> <pre><code>\u251c\u2500\u2500 src-tauri/pyembed/python\n    \u251c\u2500\u2500 bin/\n    \u251c\u2500\u2500 include/\n    \u251c\u2500\u2500 lib/\n    \u2514\u2500\u2500 share/\n</code></pre> <p>Tell <code>tauri-cli</code> to ignore it during <code>tauri dev</code>:</p> src-tauri/.taurignore<pre><code># ...\n/pyembed/\n</code></pre> <p>Tip</p> <p>If you are using an IDE based on <code>pyright</code>/<code>pylance</code>, please create a <code>pyproject.toml</code> file in the root directory of your project (not <code>src-tauri/pyproject.toml</code>) and add the following configuration to tell <code>pyright</code> not to analyze <code>src-tauri/pyembed</code>, as it will consume a large amount of memory:</p> pyproject.toml<pre><code>[tool.pyright]\n# see: &lt;https://github.com/microsoft/pyright/blob/1.1.391/docs/configuration.md#environment-options&gt;\nexclude = [\n    \"**/node_modules\",\n    \"**/__pycache__\",\n    # \ud83d\udc47 necessary, because when `tauri-cli bundles python,\n    # it will copy `pyembed` to the target directory (i.e., rust output dir).\n    \"**/target\",\n    # \ud83d\udc46\n    \"**/dist\",\n    \"**/.venv\",\n    \"**/.*\",\n    \"src-tauri/pyembed/\",\n    \"src-tauri/frontend/\",\n]\n</code></pre>"},{"location":"usage/tutorial/build-standalone/#install-your-project-into-the-embedded-python-environment","title":"Install your project into the embedded Python environment","text":"windowsunix <pre><code>$env:PYTAURI_STANDALONE=\"1\"  # see `setup.py`\n\n# `tauri-app` is your python package name.\nuv pip install `\n    --exact `\n    --python=\".\\src-tauri\\pyembed\\python\\python.exe\" `\n    --reinstall-package=tauri-app `\n    .\\src-tauri\n</code></pre> <pre><code>export PYTAURI_STANDALONE=\"1\"  # see `setup.py`\n\n# `tauri-app` is your python package name.\nuv pip install \\\n    --exact \\\n    --python=\"./src-tauri/pyembed/python/bin/python3\" \\\n    --reinstall-package=tauri-app \\\n    ./src-tauri\n</code></pre> <p>Warning</p> <p>Unlike <code>editable install</code> during development, you need to reinstall your project every time you modify the Python code.</p>"},{"location":"usage/tutorial/build-standalone/#configure-tauri-cli","title":"Configure <code>tauri-cli</code>","text":"<p>ref: https://tauri.app/reference/config/#bundle</p> <p>Create following <code>tauri-cli</code> configuration file:</p> src-tauri/tauri.bundle.json<pre><code>{\n    \"bundle\": {\n        \"active\": true,\n        \"targets\": \"all\",\n        \"resources\": {\n            \"pyembed/python\": \"./\"\n        }\n    }\n}\n</code></pre> <p>ref: https://doc.rust-lang.org/cargo/reference/profiles.html</p> <p>Add the following configuration to <code>Cargo.toml</code>:</p> src-tauri/Cargo.toml<pre><code># ...\n\n[profile.bundle-dev]\ninherits = \"dev\"\n\n[profile.bundle-release]\ninherits = \"release\"\n</code></pre>"},{"location":"usage/tutorial/build-standalone/#build-and-bundle","title":"Build and bundle","text":"<p>ref: https://pyo3.rs/v0.23.3/building-and-distribution.html#configuring-the-python-version</p> <p>Indicate pyo3 to use the embedded Python interpreter through environment variables, so it does not mistakenly use the system Python interpreter.</p> windowsunix <pre><code>$env:PYO3_PYTHON = (Resolve-Path -LiteralPath \".\\src-tauri\\pyembed\\python\\python.exe\").Path\n</code></pre> <pre><code>export PYO3_PYTHON=$(realpath ./src-tauri/pyembed/python/bin/python3)\n</code></pre> <p>Configure <code>RUSTFLAGS</code>:</p> windowsunix <p>Nothing you need to do. Only unix need to set <code>RUSTFLAGS</code>.</p> <ul> <li>There is currently an issue with the <code>sysconfig</code> of <code>python-build-standalone</code>,     which causes <code>pyo3</code> to fail to automatically find <code>libpython3</code> during compilation, so we need to set it manually.</li> <li>We use tauri's <code>resource_dir</code> to bundle the portable Python,     so we need to set <code>rpath</code> to tell our binary how to find the bundled <code>libpython3</code> at runtime.</li> </ul> linuxmacos <pre><code># `tauri-app` is your app `productName` in `tauri.conf.json`.\nexport RUSTFLAGS=\" \\\n    -C link-arg=-Wl,-rpath,\\$ORIGIN/../lib/tauri-app/lib \\\n    -L $(realpath ./src-tauri/pyembed/python/lib)\"\n</code></pre> <pre><code>export RUSTFLAGS=\" \\\n    -C link-arg=-Wl,-rpath,@executable_path/../Resources/lib \\\n    -L $(realpath ./src-tauri/pyembed/python/lib)\"\n</code></pre> <p>Finally, use <code>tauri-cli</code> to bundle:</p> <pre><code>pnpm -- tauri build --config=\"src-tauri/tauri.bundle.json\" -- --profile bundle-release\n</code></pre> <p>Warning</p> <p>DO NOT set <code>bundle.resources</code> in <code>tauri.conf.json</code> directly.</p> <p>The <code>tauri-cli</code> will copy <code>bundle.resources</code> to <code>target/release(debug)</code>, which is in the same location as your executable. This will incorrectly cause the copied Python environment to be the Python environment linked at runtime during <code>tauri dev</code>. However, during development, you should use a <code>venv</code> virtual environment.</p> <p>By using <code>--profile bundle-release</code>, we ensure that <code>target/release(debug)</code> is not affected, allowing you to use <code>tauri dev</code> normally.</p>"},{"location":"usage/tutorial/build-wheel/","title":"Build python Wheel distribution","text":"<p>Although you have built the sdist in the previous step and can build the wheel using <code>setuptools-rust</code>, take a look at the output wheel file name <code>tauri-app-0.1.0-cp39-cp39-linux_x86_64.whl</code>.</p> <p>According to https://packaging.python.org/en/latest/specifications/platform-compatibility-tags/, this indicates that the wheel can only be used on <code>CPython == 3.9</code>.</p> <p>This means that if you want to distribute the wheel built in this way, you need to build a wheel for each CPython version.</p> <p>Additionally, PyPI will not allow you to upload wheels with the <code>linux*</code> tag because such a tag does not specify the libc version required to run the wheel. PyPI only allows manylinux and musllinux.</p> <p>Info</p> <p>This is not an issue for users who use your sdist, as they will build the wheel in their own environment and do not need to distribute that wheel.</p>"},{"location":"usage/tutorial/build-wheel/#maturin","title":"Maturin","text":"<p>To make it easier to build distributable wheels, we recommend using maturin, which is a <code>setuptools-rust</code> with batteries included.</p> <p>First, install it (<code>v1.8.0</code>) using uv:</p> windows or macoslinux <pre><code>uv pip install maturin\n</code></pre> <pre><code>uv pip install maturin[patchelf]\n</code></pre> <p>Add the following configuration, which is the same as the configuration for <code>setuptools-rust</code>:</p> src-tauri/pyproject.toml<pre><code># see: &lt;https://www.maturin.rs/config&gt;\n[tool.maturin]\n# the same as [tool.setuptools.packages.find.where]\npython-source = \"python\"\n# the same as `[project.entry-points.pytauri.ext_mod]`,\n# i.e., `target` in `setup.py`\nmodule-name = \"tauri_app.ext_mod\"\n# see `setup.py`\nfeatures = [\"pyo3/extension-module\", \"tauri/custom-protocol\"]\n# equivalent to `setuptools_scm`\nsdist-generator = \"git\"\n# equivalent to `MANIFEST.in`\ninclude = [{ path = \"frontend/**/*\", format = \"sdist\" }]\n</code></pre>"},{"location":"usage/tutorial/build-wheel/#build-manylinux-wheel","title":"Build manylinux wheel","text":"<p>ref: https://www.maturin.rs/distribution#build-wheels</p> <p>Maturin can automatically detect the current system's glibc version and assign the appropriate tag to the built wheel. Use the following command to build a manylinux wheel:</p> <pre><code>cd src-tauri\npnpm build  # build frontend assets\nmaturin build --release  # `--strip` &lt;-- optional to reduce the size\ncd ..\n</code></pre> <p>When you build on <code>ubuntu 22.04 (glibc 2.35)</code>, you will get a wheel file named <code>*-manylinux_2_35_*.whl</code>. The <code>manylinux_2_35</code> tag indicates that the wheel can run on systems with <code>glibc &gt;= 2.35</code>.</p> <p>If you want to support as many systems as possible, you should build the wheel on an older system. However, please note that the dependencies of <code>tauri v2</code> require you to use <code>ubuntu 22+</code>.</p>"},{"location":"usage/tutorial/build-wheel/#bundle-system-dependencies-with-the-wheel","title":"Bundle system dependencies with the wheel","text":"<p>According to PEP513, the manylinux wheel you built in the previous step can only link to a limited set of system libraries at runtime. To meet this requirement, maturin will copy and bundle these system libraries (including tauri's dependencies) during the build process, similar to how AppImage works.</p> <p>Tip</p> <p>Not all linked libraries will be bundled. Some libraries commonly found in various Linux distributions will be whitelisted. See more:</p> <ul> <li>https://github.com/pypa/auditwheel/issues/78</li> <li>https://github.com/kuelumbus/rdkit-pypi/issues/75</li> <li>https://github.com/PyO3/maturin/blob/f5b807eaf3f576ea08e6a574d699fc6f54e2be46/src/auditwheel/manylinux-policy.json#L454</li> </ul> <p>Building the wheel in this way means your users will no longer need to manually install dependencies. However, note that this will increase your wheel size from 10MB to 100MB.</p> <p>If you do not want this behavior, skip patching and manually specify the manylinux tag:</p> <pre><code>maturin build --release --auditwheel skip --manylinux 2_35 # &lt;-- your glibc version\n</code></pre> <p>Then, require your users to install these dependencies before running the wheel:</p> <p>ref: https://tauri.app/distribute/debian/#debian</p> <ul> <li>libwebkit2gtk-4.1-0</li> <li>libgtk-3-0</li> <li>libappindicator3-1 (if your app uses the system tray)</li> </ul>"},{"location":"usage/tutorial/build-wheel/#build-abi3-wheel","title":"Build abi3 wheel","text":"<p>ref: https://www.maturin.rs/bindings.html#py_limited_apiabi3</p> <p>add pyo3 feature <code>pyo3/abi3-py3*</code>:</p> src-tauri/pyproject.toml<pre><code>[tool.maturin]\n# ...\nfeatures = [\"pyo3/extension-module\", \"tauri/custom-protocol\", \"pyo3/abi3-py39\"]\n</code></pre> <p>then build your wheel:</p> <pre><code>maturin build --release  # your maturin args\n</code></pre> <p>you will get a wheel file named <code>*-cp39-abi3-*.whl</code>, which means that the wheel can run on <code>CPython &gt;= 3.9</code>.</p> <p>Info</p> <p>The <code>pytauri/standalone</code> feature is incompatible with the <code>pyo3/abi3</code> feature, which is why we only enable it in <code>[[bin]]</code> target.</p>"},{"location":"usage/tutorial/build-wheel/#whats-projectentry-pointspytauri-mean","title":"What's <code>project.entry-points.pytauri</code> mean?","text":"<p>Now it's time to explain <code>[project.entry-points.pytauri]</code>.</p> <p>Looking at the contents of the <code>.whl</code>, you will see the following structure:</p> <pre><code>\u2514\u2500\u2500 tauri_app-0.1.0-*.whl\n    \u251c\u2500\u2500 tauri_app\n    \u2502   \u251c\u2500\u2500 __init__.py\n    \u2502   \u251c\u2500\u2500 __main__.py\n    \u2502   \u2514\u2500\u2500 ext_mod.*.so/pyd\n    \u2514\u2500\u2500 ...\n</code></pre> <p>We indicate the extension module <code>mod ext_mod</code> in <code>lib.rs</code> to be compiled into the <code>tauri_app/ext_mod.*.so/pyd</code> file by:</p> <ul> <li><code>setup.py (setuptools-rust)</code>: <code>target=\"tauri_app.ext_mod\"</code></li> <li><code>pyproject.toml (maturin)</code>: <code>module-name = \"tauri_app.ext_mod\"</code></li> </ul> <p>Warning</p> <p><code>pytauri</code> does not have any opinion on where you place the extension module, but note that in <code>lib.rs</code> we specified the extension module name with <code>#[pyo3(name = \"ext_mod\")]</code>, so your extension module file name must match this name.</p> <p>Finally, we tell pytauri how to find it through <code>project.entry-points.pytauri.ext_mod = \"tauri_app.ext_mod\"</code> in <code>pyproject.toml</code>.</p>"},{"location":"usage/tutorial/getting-started/","title":"Getting Started","text":"<p>Before starting the tutorial, we recommend installing the following tools, which are considered best practices for initializing a pytauri project. We will use these tools throughout the tutorial.</p> <ul> <li>create-tauri-app: <code>v4.5.9</code></li> <li>uv: <code>v0.5.11</code></li> <li>tauri-cli: <code>v2.1.0</code></li> </ul> <p>Note</p> <p>The specified versions above are the ones used when writing this tutorial. You can use other versions, but the usage might differ from the examples in this tutorial.</p>"},{"location":"usage/tutorial/getting-started/#full-example","title":"Full Example","text":"<p>https://github.com/WSH032/pytauri/tree/main/examples/tauri-app</p>"},{"location":"usage/tutorial/getting-started/#create-a-new-tauri-project","title":"Create a new tauri project","text":"<p>ref: https://tauri.app/start/create-project/#using-create-tauri-app</p> <p>Note</p> <p>In this tutorial, we will use pnpm to manage the frontend.</p> <p>However, pytauri does not have any opinion on which frontend framework you use. You can even serve the frontend resources via a server using a URL.</p> <pre><code>pnpm create tauri-app\n\n? Project name (tauri-app) \u203a\n? Identifier (com.tauri-app.app) \u203a\n? Choose which language to use for your frontend \u203a\n    \u276f TypeScript / JavaScript  (pnpm, yarn, npm, deno, bun)\n? Choose your package manager \u203a\n    \u276f pnpm\n? Choose your UI template \u203a\n    \u276f Vanilla\n? Choose your UI flavor \u203a\n    \u276f TypeScript\n</code></pre> <p>You will get the following directory structure:</p> <pre><code>\u2514\u2500\u2500 tauri-app\n    \u251c\u2500\u2500 README.md\n    \u251c\u2500\u2500 index.html\n    \u251c\u2500\u2500 package.json\n    \u251c\u2500\u2500 src\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 assets\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 main.ts\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 styles.css\n    \u251c\u2500\u2500 src-tauri\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 Cargo.toml\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 build.rs\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 capabilities\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 icons\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 src\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 tauri.conf.json\n    \u251c\u2500\u2500 tsconfig.json\n    \u2514\u2500\u2500 vite.config.ts\n</code></pre> <ul> <li><code>/tauri-app</code>: for the frontend</li> <li><code>/tauri-app/src-tauri</code>: for rust and python backend</li> </ul>"},{"location":"usage/tutorial/getting-started/#launch-the-tauri-app","title":"Launch the tauri app","text":"<pre><code>cd tauri-app\npnpm install  # (1)!\npnpm tauri dev  # (2)!\n</code></pre> <ol> <li>This command will install <code>tuari-cli</code></li> <li>use <code>tauri-cli</code> to start the app</li> </ol> <p>Info</p> <p>The first run will take some time to compile the dependencies, subsequent launches will be much faster.</p> <p>Congratulations! When you finally see a window with web content appear, you have successfully created a Tauri application.</p>"},{"location":"usage/tutorial/getting-started/#next-steps","title":"Next Steps","text":"<p>Next, we will demonstrate how to integrate Python into the Tauri application using pytauri.</p>"},{"location":"usage/tutorial/py-js-ipc/","title":"IPC between Python and JavaScript","text":"<p>pytauri implements the same IPC API as tauri. You can use it through pytauri.Commands.</p> <p>This tutorial will demonstrate how to use pytauri's IPC API by rewriting the <code>fn greet</code> command in <code>src-tauri/src/lib.rs</code> in Python.</p>"},{"location":"usage/tutorial/py-js-ipc/#enable-pytauri-ipc-permission","title":"Enable pytauri ipc permission","text":"<p>pytauri internally implements IPC through <code>tauri-plugin-pytauri</code>. You need to add it to the dependencies so that you can enable its permission in tauri.</p> src-tauri/Cargo.toml<pre><code># ...\n\n[dependencies]\n# ...\ntauri-plugin-pytauri = { version = \"0.1.0-beta.0\" }\n</code></pre> <p>Refer to https://tauri.app/security/capabilities/ to add the permission:</p> src-tauri/capabilities/default.json<pre><code>{\n    // ...\n    \"permissions\": [\n        // ...\n        \"pytauri:default\"\n    ]\n}\n</code></pre>"},{"location":"usage/tutorial/py-js-ipc/#ipc-in-python","title":"IPC in python","text":""},{"location":"usage/tutorial/py-js-ipc/#install-dependencies","title":"install dependencies","text":"<p>pytauri relies on pydantic for serialization and validation, and on anyio for <code>asyncio</code>/<code>trio</code> support.</p> <p>Therefore, you need to install these dependencies:</p> src-tauri/pyproject.toml<pre><code># ...\n\n[project]\n# ...\ndependencies = [\n    # ...\n    \"pydantic == 2.*\",\n    \"anyio == 4.*\"\n]\n</code></pre> <p>Tip</p> <p>After adding dependencies, you need to use commands like <code>uv sync</code> or <code>uv pip install</code> to synchronize your dependency environment.</p>"},{"location":"usage/tutorial/py-js-ipc/#add-command","title":"add command","text":"<p>see concepts/ipc for more information.</p> src-tauri/python/__init__.py<pre><code>import sys\n\nfrom anyio.from_thread import start_blocking_portal\nfrom pydantic import BaseModel\nfrom pytauri import (\n    BuilderArgs,\n    Commands,\n    builder_factory,\n    context_factory,\n)\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person) -&gt; Greeting:\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n</code></pre>"},{"location":"usage/tutorial/py-js-ipc/#generate-invoke-handler-for-app","title":"generate invoke handler for app","text":"src-tauri/python/__init__.py<pre><code># --8&lt;-- [start:command]\n\nimport sys\n\nfrom anyio.from_thread import start_blocking_portal\nfrom pydantic import BaseModel\nfrom pytauri import (\n    BuilderArgs,\n    Commands,\n    builder_factory,\n    context_factory,\n)\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person) -&gt; Greeting:\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n\n\n# --8&lt;-- [end:command]\n\n\ndef main() -&gt; None:\n    with start_blocking_portal(\"asyncio\") as portal:  # or `trio`\n        app = builder_factory().build(\n            BuilderArgs(\n                context=context_factory(),\n                # \ud83d\udc47\n                invoke_handler=commands.generate_handler(portal),\n                # \ud83d\udc46\n            )\n        )\n        app.run()\n</code></pre>"},{"location":"usage/tutorial/py-js-ipc/#ipc-in-javascript","title":"IPC in JavaScript","text":"<p>pytauri provides an API similar to the <code>invoke</code> function in <code>@tauri-apps/api/core</code> through <code>tauri-plugin-pytauri-api</code>.</p> <p>First, install it: <code>pnpm add tauri-plugin-pytauri-api</code>.</p> <p>Now, you can invoke the command from your JavaScript code:</p> src/main.ts<pre><code>import { invoke } from \"@tauri-apps/api/core\";\nimport { pyInvoke } from \"tauri-plugin-pytauri-api\";\n// or if tauri config `app.withGlobalTauri = true`:\n//\n// ```js\n// const { pyInvoke } = window.__TAURI__.pytauri;\n// ```\n\ninterface Greeting {\n  message: string;\n}\n\nasync function greet() {\n  if (greetMsgEl &amp;&amp; greetInputEl) {\n    // Learn more about Tauri commands at https://tauri.app/develop/calling-rust/\n    const rsGreeting = await invoke&lt;string&gt;(\"greet\", {\n      name: greetInputEl.value,\n    });\n    const pyGreeting = await pyInvoke&lt;Greeting&gt;(\"greet\", {\n      name: greetInputEl.value,\n    });\n    greetMsgEl.textContent = rsGreeting + \"\\n\" + pyGreeting.message;\n  }\n}\n</code></pre>"},{"location":"usage/tutorial/using-plugins/","title":"Using tauri plugins","text":"<p>The Tauri team and community have developed some plugins, you can use them by:</p> <ol> <li>Official Tauri plugins usually provide corresponding JavaScript APIs, which you can use directly on the frontend.</li> <li>Write your own Rust functions using pyo3 and expose them to Python.</li> </ol> <p>PyTauri has provided Python APIs for some Tauri plugins using the second method, and they are called <code>pytauri-plugin-*</code>.</p> <p>Below, we use <code>pytauri-plugin-notification</code> as an example to demonstrate how to use pytauri plugins.</p>"},{"location":"usage/tutorial/using-plugins/#using-the-plugin","title":"Using the plugin","text":""},{"location":"usage/tutorial/using-plugins/#install-tauri-plugin","title":"install tauri plugin","text":"<p>All PyTauri plugins are just Python bindings, which means you need to initialize the underlying Tauri extensions normally:</p> <pre><code>pnpm tauri add notification\n</code></pre>"},{"location":"usage/tutorial/using-plugins/#expose-the-pyo3-bingings-to-python","title":"expose the pyo3 bingings to python","text":"<p>PyTauri plugins usually export their pyo3 API with the following conventions:</p> <ol> <li>Export a Rust <code>mod</code> with the same name as the plugin at the top level.</li> <li>Export a function named <code>pymodule_export</code> at the top level.<ul> <li>The pyo3 API of <code>pytauri</code> itself is exported in this way: <code>pytauri::pymodule_export</code></li> </ul> </li> </ol> <p><code>pytauri-plugin-notification</code> uses the first method.</p> <p>Add the rust dependency:</p> <pre><code>cd src-tauri\ncargo add pytauri-plugin-notification@0.1.0-beta.0\ncd ..\n</code></pre> <p>ref to https://pyo3.rs/v0.23.3/module.html to export the pyo3 bindings:</p> src-tauri/src/lib.rs<pre><code>use pyo3::prelude::*;\n// ...\n\n#[pymodule(gil_used = false)]\n#[pyo3(name = \"ext_mod\")]\npub mod ext_mod {\n\n    #[pymodule_export]\n    use pytauri_plugin_notification::notification;\n\n    // ...\n}\n</code></pre>"},{"location":"usage/tutorial/using-plugins/#use-plugin-api-from-python","title":"use plugin api from python","text":"<p>Add the python dependency:</p> src-tauri/pyproject.toml<pre><code># ...\n\n[project]\n# ...\ndependencies = [\n    # ...\n    \"pytauri-plugin-notification == 0.1.*\",\n]\n</code></pre> <p>Tip</p> <p>After adding dependencies, you need to use commands like <code>uv sync</code> or <code>uv pip install</code> to synchronize your dependency environment.</p> <p>The PyTauri API maps very well to the original Rust API of the plugin. You can refer to the Rust documentation to understand how to use it:</p> src-tauri/python/__init__.py<pre><code>import sys\n\nfrom pydantic import BaseModel\nfrom pytauri import AppHandle, Commands\nfrom pytauri_plugin_notification import NotificationBuilderArgs, NotificationExt\n\ncommands: Commands = Commands()\n\n\nclass Person(BaseModel):\n    name: str\n\n\nclass Greeting(BaseModel):\n    message: str\n\n\n@commands.command()\nasync def greet(body: Person, app_handle: AppHandle) -&gt; Greeting:\n    notification_builder = NotificationExt.builder(app_handle)\n    notification_builder.show(\n        NotificationBuilderArgs(title=\"Greeting\", body=f\"Hello, {body.name}!\")\n    )\n\n    return Greeting(\n        message=f\"Hello, {body.name}! You've been greeted from Python {sys.version}!\"\n    )\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/","title":"Using pytauri","text":"<p>Note</p> <p>The dependency versions specified in the following tutorial are the versions at the time of writing. There may be newer versions available when you use it.</p>"},{"location":"usage/tutorial/using-pytauri/#create-venv","title":"Create venv","text":"<p>Create a virtual environment using <code>uv</code>:</p> <pre><code>uv venv --python-preference only-system\n</code></pre> <p>Warning</p> <p><code>--python-preference only-system</code> is necessary. Using <code>uv</code>'s managed Python may result in not finding dynamic libraries.</p> <p>activate the virtual environment:</p> bashpowershell <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\Activate.ps1\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/#init-pyproject","title":"Init pyproject","text":"<p>Create the <code>src-tauri/python/tauri_app</code> folder to store Python code, and add the following file:</p> <p>ref: https://packaging.python.org/en/latest/guides/writing-pyproject-toml/</p> src-tauri/pyproject.toml<pre><code>[project]\nname = \"tauri-app\"  # (1)!\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \"&gt;=3.9\"\ndependencies = [\"pytauri == 0.1.*\"]  # (2)!\n\n[project.entry-points.pytauri]\next_mod = \"tauri_app.ext_mod\"\n\n[build-system]\nrequires = [\"setuptools&gt;=61\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[tool.setuptools.packages]\nfind = { where = [\"python\"] }  # (3)!\n</code></pre> <ol> <li>your python package name.</li> <li>This is the version at the time of writing this tutorial. There may be a newer version of pytauri available when you use it.</li> <li>the folder where your python code is stored, i.e., <code>src-tauri/python</code>.</li> </ol> <p>Tip</p> <p>Note the highlighted <code>project.entry-points</code>. We will explain its specific meaning when building the Wheel. For now, let's continue with the tutorial.</p>"},{"location":"usage/tutorial/using-pytauri/#install-your-project","title":"Install your project","text":"<p>Use <code>uv</code> to install your Python package in editable mode:</p> <pre><code>uv pip install -e src-tauri\n</code></pre> <p>Add following code:</p> src-tauri/python/tauri_app/__init__.py<pre><code>\"\"\"The tauri-app.\"\"\"\n\nfrom pytauri import (\n    BuilderArgs,\n    builder_factory,\n    context_factory,\n)\n\n\ndef main() -&gt; None:\n    \"\"\"Run the tauri-app.\"\"\"\n    app = builder_factory().build(\n        BuilderArgs(\n            context=context_factory(),\n        )\n    )\n    app.run()\n</code></pre> src-tauri/python/tauri_app/__main__.py<pre><code>\"\"\"The main entry point for the Tauri app.\"\"\"\n\nfrom tauri_app import main\n\nmain()\n</code></pre>"},{"location":"usage/tutorial/using-pytauri/#run-pytauri-from-rust","title":"Run pytauri from rust","text":"<p>Add following dependencies to <code>Cargo.toml</code>:</p> <p>ref: https://doc.rust-lang.org/cargo/reference/cargo-targets.html#binaries</p> src-tauri/Cargo.toml<pre><code># ...\n\n[[bin]]\n# the same as the package name\nname = \"tauri-app\"\npath = \"src/main.rs\"\nrequired-features = [\"pytauri/standalone\"]\n\n[dependencies]\n# ...\npyo3 = { version = \"0.23\" }\npytauri = { version = \"0.1.0-beta.0\" }\n</code></pre> <p>Also, enable the <code>pytauri/standalone</code> feature:</p> src-tauri/tauri.conf.json<pre><code>{\n    \"build\": {\n        \"features\": [\"pytauri/standalone\"]\n    }\n}\n</code></pre> <p>Warning</p> <p>If you do not enable <code>required-features</code> in <code>tauri-cli</code>, cargo will silently skip building your <code>main.rs</code> executable file.</p> <p>Change following rust code:</p> src-tauri/src/lib.rs<pre><code>use pyo3::prelude::*;\n\n// Learn more about Tauri commands at https://tauri.app/develop/calling-rust/\n#[tauri::command]\nfn greet(name: &amp;str) -&gt; String {\n    format!(\"Hello, {}! You've been greeted from Rust!\", name)\n}\n\npub fn tauri_generate_context() -&gt; tauri::Context {\n    tauri::generate_context!()\n}\n\n#[pymodule(gil_used = false)]\n#[pyo3(name = \"ext_mod\")]\npub mod ext_mod {\n    use super::*;\n\n    #[pymodule_init]\n    fn init(module: &amp;Bound&lt;'_, PyModule&gt;) -&gt; PyResult&lt;()&gt; {\n        pytauri::pymodule_export(\n            module,\n            // i.e., `context_factory` function of python binding\n            |_args, _kwargs| Ok(tauri_generate_context()),\n            // i.e., `builder_factory` function of python binding\n            |_args, _kwargs| {\n                let builder = tauri::Builder::default()\n                    .plugin(tauri_plugin_opener::init())\n                    .invoke_handler(tauri::generate_handler![greet]);\n                Ok(builder)\n            },\n        )\n    }\n}\n</code></pre> src-tauri/src/main.rs<pre><code>// Prevents additional console window on Windows in release, DO NOT REMOVE!!\n#![cfg_attr(not(debug_assertions), windows_subsystem = \"windows\")]\n\nuse std::env::var;\n\nuse pyo3::{prelude::*, wrap_pymodule};\nuse pytauri::standalone::{\n    append_ext_mod, get_python_executable_from_venv, prepare_freethreaded_python_with_executable,\n    write_py_err_to_file,\n};\nuse tauri::{Builder, Manager as _};\n\nuse tauri_app_lib::{ext_mod, tauri_generate_context};\n\nfn prepare_python_interpreter() {\n    // `cfg(dev)` is set by `tauri-build` in `build.rs`, which means running with `tauri dev`,\n    // see: &lt;https://github.com/tauri-apps/tauri/pull/8937&gt;.\n    if cfg!(dev) {\n        // virtualenv Python\n        //\n        // See:\n        //\n        // - &lt;https://github.com/PyO3/pyo3/issues/3589&gt;\n        // - &lt;https://github.com/PyO3/pyo3/issues/1896&gt;\n        //\n        // pyo3 currently cannot automatically detect the virtual environment and configure pyconfig,\n        // so we do it manually here.\n        let venv_path = var(\"VIRTUAL_ENV\").expect(\n            \"The app is running in tauri dev mode, \\\n                please activate the python virtual environment first \\\n                or set the `VIRTUAL_ENV` environment variable\",\n        );\n        let python_executable = get_python_executable_from_venv(venv_path);\n        prepare_freethreaded_python_with_executable(python_executable)\n            .expect(\"failed to initialize python from venv\");\n    } else {\n        // embedded Python, i.e., bundle mode with `tauri build`.\n\n        // Actually, we don't use this app, we just use it to get the resource directory\n        let sample_app = Builder::default()\n            .build(tauri_generate_context())\n            .expect(\"failed to build sample app\");\n        let resource_dir = sample_app\n            .path()\n            .resource_dir()\n            .expect(\"failed to get resource dir\");\n\n        let py_executable = if cfg!(windows) {\n            resource_dir.join(\"python.exe\")\n        } else {\n            resource_dir.join(\"bin/python3\")\n        };\n\n        debug_assert!(\n            py_executable.is_file(),\n            \"Python executable not found, maybe you forgot to bundle it: {}\",\n            py_executable.display()\n        );\n\n        prepare_freethreaded_python_with_executable(py_executable)\n            .expect(\"failed to initialize embedded python\");\n    }\n}\n\nfn execute_python_script(py: Python&lt;'_&gt;) -&gt; PyResult&lt;()&gt; {\n    // insert pytauri extension module into `sys.modules`\n    append_ext_mod(wrap_pymodule!(ext_mod)(py).into_bound(py))?;\n\n    // execute your Python script\n    py.run(\n        // equivalent to `python -m tauri_app`\n        c\"from runpy import run_module; run_module('tauri_app')\",\n        None,\n        None,\n    )\n}\n\nfn main() -&gt; Result&lt;(), PyErr&gt; {\n    prepare_python_interpreter();\n\n    Python::with_gil(|py| {\n        let result = execute_python_script(py);\n\n        // handle the error\n        result.inspect_err(|e| {\n            if cfg!(all(not(debug_assertions), windows)) {\n                // I.g., `windows_subsystem = \"windows\"` in `main.rs`.\n                // In this case, there is no console to print the error, so we write the error to a file\n                write_py_err_to_file(py, e, \"error.log\").expect(\"failed to write error to file\");\n            } else {\n                // we have a console, so we just call `sys.excepthook` and print the error\n                e.print_and_set_sys_last_vars(py);\n            }\n        })\n    })\n}\n</code></pre> <p>\ud83d\udc46 Note the highlighted part, it will execute the code in <code>src-tauri/python/tauri_app/__main__.py</code>.</p>"},{"location":"usage/tutorial/using-pytauri/#launch-the-app-in-dev-mode","title":"Launch the app in dev mode","text":"<p>The <code>tauri-cli</code> has the ability to watch code changes and hot reload. Before starting, we need to add the following file to tell <code>tauri-cli</code> to ignore the python bytecode:</p> <p>ref: https://tauri.app/develop/#reacting-to-source-code-changes</p> src-tauri/.taurignore<pre><code>__pycache__\n</code></pre> <p>Also, we need tell <code>vite</code> to ignore <code>.venv</code>:</p> vite.config.ts<pre><code>// https://vitejs.dev/config/\nexport default defineConfig(async () =&gt; ({\n  server: {\n    watch: {\n      // 3. tell vite to ignore watching `src-tauri`\n      ignored: [\"**/src-tauri/**\", \"**/.venv/**\"],\n    },\n  },\n}));\n</code></pre> <p>Run <code>pnpm tauri dev</code>, and after recompiling, you will see a window similar to the previous step.</p> <p>Try modifying the Python code, and you will notice that the Python code is quickly reloaded without needing to recompile the Rust code.</p>"},{"location":"usage/tutorial/using-pytauri/#next-steps","title":"Next Steps","text":"<p>Next, we will demonstrate how to package your application.</p>"}]}